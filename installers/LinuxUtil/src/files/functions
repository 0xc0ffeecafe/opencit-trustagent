#!/bin/bash
# WARNING:
# *** do NOT use TABS for indentation, use SPACES
# *** TABS will cause errors in some linux distributions

# CONFIGURATION:

# TERM_DISPLAY_MODE can be "plain" or "color"
TERM_DISPLAY_MODE=color
TERM_STATUS_COLUMN=60
TERM_COLOR_GREEN="\\033[1;32m"
TERM_COLOR_RED="\\033[1;31m"
TERM_COLOR_YELLOW="\\033[1;33m"
TERM_COLOR_NORMAL="\\033[0;39m"


DEFAULT_MYSQL_HOSTNAME="127.0.0.1"
DEFAULT_MYSQL_PORTNUM="3306"
DEFAULT_MYSQL_USERNAME="root"
DEFAULT_MYSQL_PASSWORD=""
DEFAULT_MYSQL_DATABASE="mw_as"

export INSTALL_LOG_FILE=/tmp/mtwilson-install.log

### FUNCTION LIBRARY: terminal display functions

# move to column 60:    term_cursor_movex $TERM_STATUS_COLUMN
# Environment:
# - TERM_DISPLAY_MODE
term_cursor_movex() {
  local x="$1"
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then
    echo -en "\\033[${x}G"
  fi
}

# Environment:
# - TERM_DISPLAY_MODE
# - TERM_DISPLAY_GREEN
# - TERM_DISPLAY_NORMAL
echo_success() {
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_GREEN}"; fi
  echo ${@:-"[  OK  ]"}
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  return 0
}

# Environment:
# - TERM_DISPLAY_MODE
# - TERM_DISPLAY_RED
# - TERM_DISPLAY_NORMAL
echo_failure() {
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_RED}"; fi
  echo ${@:-"[FAILED]"}
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  return 1
}

# Environment:
# - TERM_DISPLAY_MODE
# - TERM_DISPLAY_YELLOW
# - TERM_DISPLAY_NORMAL
echo_warning() {
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo ${@:-"[WARNING]"}
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  return 1
}

### SHELL FUNCTIONS

# parameters: space-separated list of files to include (shell functions or configuration)
# example:  shell_include_files /path/to/file1 /path/to/file2 /path/to/file3 ...
# if any file does not exist, it is skipped
shell_include_files() {
  for filename in "$@"
  do
    if [ -f "${filename}" ]; then
      . ${filename}
    fi
  done
}


### FUNCTION LIBRARY: information functions

# extracts the major version number (1) out of a string like 1.2.3_4
version_major() {
  echo "${1}" | awk -F . '{ print $1 }'
}
# extracts the minor version number (2) out of a string like 1.2.3_4
version_minor() {
  echo "${1}" | awk -F . '{ print $2 }'
}
# extracts the second minor version number (3) out of a string like 1.2.3_4
version_extract3() {
  local thirdpart=`echo "${1}" | awk -F . '{ print $3 }'`
  echo "${thirdpart}" | awk -F _ '{ print $1 }'
}
# extracts the fourth minor version number (4) out of a string like 1.2.3_4
version_extract4() {
  local thirdpart=`echo "${1}" | awk -F . '{ print $3 }'`
  echo "${thirdpart}" | awk -F _ '{ print $2 }'
}

# two arguments: actual version number (string), required version number (string)
# example:  `is_version_at_least 4.9 5.0` will return "no" because 4.9 < 5.0
is_version_at_least() {
  local testver="${1}"
  local reqver="${2}"
  local hasmajor=`version_major "${testver}"`
  local hasminor=`version_minor "${testver}"`
  local reqmajor=`version_major "${reqver}"`
  local reqminor=`version_minor "${reqver}"`
  if [[
       -n "${reqmajor}" && "${hasmajor}" -gt "${reqmajor}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -z "${reqminor}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -n "${reqminor}" && "${hasminor}" -ge "${reqminor}"
     ]]; then
    echo "yes"
  else
    echo "no"
  fi  
}

# like is_version_at_least but works on entire java version string 1.6.0_29
# instead of just a major.minor number
# Parameters:
# - version to test (of installed software)
# - minimum required version
is_java_version_at_least() {
  local testver="${1}"
  local reqver="${2}"
  local hasmajor=`version_major "${testver}"`
  local hasminor=`version_minor "${testver}"`
  local hasminor3=`version_extract3 "${testver}"`
  local hasminor4=`version_extract4 "${testver}"`
  local reqmajor=`version_major "${reqver}"`
  local reqminor=`version_minor "${reqver}"`
  local reqminor3=`version_extract3 "${reqver}"`
  local reqminor4=`version_extract4 "${reqver}"`
  if [[
       -n "${reqmajor}" && "${hasmajor}" -gt "${reqmajor}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -z "${reqminor}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -n "${reqminor}" && "${hasminor}" -gt "${reqminor}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}"
       && -n "${reqminor3}" && "${hasminor3}" -gt "${reqminor3}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}"
       && -z "${reqminor3}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}"
       && -n "${reqminor3}" && "${hasminor3}" -eq "${reqminor3}"
       && -z "${reqminor4}"
     ||
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}"
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}"
       && -n "${reqminor3}" && "${hasminor3}" -eq "${reqminor3}"
       && -n "${reqminor4}" && "${hasminor4}" -ge "${reqminor4}" 
     ]]; then
    echo "yes"
  else
    echo "no"
  fi  
}

# Parameters:
# - variable name to set with result
# - prompt (string)
# will accept y, Y, or nothing as yes, anything else as no
prompt_yes_no() {
  local resultvarname="${1}"
  local userprompt="${2}"
  # bug #512 add support for answer file
  if [ -n "${!resultvarname}" ]; then
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
    echo "$userprompt [Y/n] ${!resultvarname}"
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
    return
  fi
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo -n "$userprompt [Y/n] "
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  local userinput
  read -n 1 userinput
  echo
  if [[ $userinput == "Y" || $userinput == "y" || $userinput == "" ]]; then
    eval $resultvarname="yes"
  else
    eval $resultvarname="no"
  fi
}

# Parameters:
# - character like 'a' for which to echo the character code
# echos the character code of the specified character
# For example:   ord a     will echo 97
ord() { printf '%d' "'$1"; }

# Parameters:
# - variable name to set with result
# - prompt text (include any punctuation such as ? or : you want to display)
# - default setting (do not include any brackets or punctuation). 
#   If the default setting is omitted, the current value of the output variable name will be used.
# Output:
# - result (input or default) is saved into the specified variable name
#
# Examples:
#   prompt_with_default USERNAME "What is your name?"
#   prompt_with_default USERCOLOR "What is your favorite color?" ${DEFAULT_COLOR}
prompt_with_default() {
  local resultvarname="${1}"
  local userprompt="${2}"
  local default_value
  eval default_value="${3:-\$$resultvarname}"
  # bug #512 add support for answer file
  if [ -n "${!resultvarname}" ]; then
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
    echo "$userprompt [$default_value] ${!resultvarname:-$default_value}"
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
    return
  fi
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo -n "$userprompt [$default_value] "
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  local userinput
  read userinput
  eval $resultvarname=${userinput:-$default_value}
}

# Same as prompt_with_default, but the default value is hidden by *******,
# and if prompt text is not provided then the default prompt is "Password:"
prompt_with_default_password() {
  local resultvarname="${1}"
  local userprompt="${2:-Password:}"
  local default_value
  eval default_value="${3:-\$$resultvarname}"
  local default_value_display="********"
  # bug #512 add support for answer file
  if [ -n "${!resultvarname}" ]; then
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
    echo "$userprompt [$default_value_display] ${default_value_display}"
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
    return
  fi
  if [ -z "$default_value" ]; then default_value_display=""; fi;
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo -n "$userprompt [$default_value_display] "
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  local userinput=""
  #IFS= read -r -s userinput
  #echo
  local input_counter=0
  local char
  while IFS= read -r -s -n 1 char
  do
    local code=`ord $char`
    if [[ $char == $'\0' ]]; then
      break
    elif [[ "$code" == "8" || "$code" == "127" ]]; then
      if (($input_counter > 0)); then
        echo -n $'\b \b';
        ((input_counter--))
        userinput="${userinput%?}"
      fi
    else
      echo -n '*'
      userinput+="$char";
      ((input_counter++))
    fi
  done
  echo
  eval $resultvarname=${userinput:-$default_value}
}

### FUNCTION LIBRARY: environment information functions

# Usage example:   if using_glassfish; then echo "Using glassfish"; fi
using_glassfish() { if [[ "${WEBSERVER_VENDOR}" == "glassfish" ]]; then return 0; else return 1; fi }
using_tomcat() { if [[ "${WEBSERVER_VENDOR}" == "tomcat" ]]; then return 0; else return 1; fi }
using_mysql() { if [[ "${DATABASE_VENDOR}" == "mysql" ]]; then return 0; else return 1; fi }
using_postgres() { if [[ "${DATABASE_VENDOR}" == "postgres" ]]; then return 0; else return 1; fi }

### FUNCTION LIBARRY: conditional execution functions

# TODO: rename to positive_condition
# parameters: condition variable name, status line, code to run
# Will print "status line... " and then "OK" or "FAILED"
action_condition() {
  local condvar="${1}"
  local statusline="${2}"
  local condfn="${3}"
  local cond=$(eval "echo \$${condvar}")
  echo -n "$statusline"
  echo -n "... "
  if [ -n "$cond" ]; then
    echo_success "Skipped"
  else # if [ -z "$cond" ]; then
    eval "$condfn"
    cond=$(eval "echo \$${condvar}")
    if [ -n "$cond" ]; then
      echo_success "OK"
    else
      echo_failure "FAILED"
    fi
  fi
}
# TODO: rename to negative_condition
# similar to action_condition but reverses the logic: empty is OK, defined is FAILED
inaction_condition() {
  local condvar="${1}"
  local statusline="${2}"
  local condfn="${3}"
  local cond=$(eval "echo \$${condvar}")
  echo -n "$statusline"
  echo -n "... "
  if [ -z "$cond" ]; then
    echo_success "Skipped"
  else # if [ -z "$cond" ]; then
    eval "$condfn"
    cond=$(eval "echo \$${condvar}")
    if [ -z "$cond" ]; then
      echo_success "OK"
    else
      echo_failure "FAILED"
    fi
  fi
}

### FUNCTION LIBRARY: file management

# parameter: one or more paths to check for existence
# output: the first entry found to exist
# example:
# mybinary=`first_existing /usr/local/bin/ahctl /usr/bin/ahctl /opt/local/bin/ahctl /opt/bin/ahctl /opt/intel/cloudsecurity/attestation-service/bin/ahctl`
first_existing() {
    local search_locations="$@"
    local file
    for file in $search_locations
    do
      if [[ -e "$file" ]]; then
        echo "$file"
        return 0
      fi
    done
    return 1
}

# parameters: one or more files/directories to check for existence
# return value: returns 0 if all files are present, 1 if any are missing; displays report on screen
# example:
# report_files_exist /etc/file1 /etc/file2
report_files_exist() {
    local search_locations="$@"
    local report_summary=0
    local file
    for file in $search_locations
    do
      if [[ -e "$file" ]]; then
        echo_success "$file" exists
      else
        echo_failure "$file" missing
        report_summary=1
      fi
    done
    return $report_summary
}

# makes a date-stamped backup copy of a file
backup_file() {
  local filename="${1}"
  local datestr=`date +%Y-%m-%d.%H%M`
  local backup_filename="${filename}.${datestr}"
  if [[ -n "$filename" && -f "$filename" ]]; then
    cp ${filename} ${backup_filename}
    echo "${backup_filename}"
  fi
}

# read a property from a property file formatted like NAME=VALUE
# parameters: property name, filename
# example: read_property_from_file MYFLAG FILENAME
# Automatically strips Windows carriage returns from the file
read_property_from_file() {
  local property="${1}"
  local filename="${2}"
  if [ -f "$filename" ]; then
    local found=`cat "$filename" | grep "^$property"`
    if [ -n "$found" ]; then
      #echo -n `cat "$filename" | tr -d '\r' | grep "^$property" | tr -d '\n' | awk -F '=' '{ print $2 }'`
      echo `cat "$filename" | tr -d '\r' | grep "^$property" | head -n 1 | awk -F '=' '{ print $2 }'`
    fi
  fi
}

# write a property into a property file, replacing the previous value
# parameters: property name, filename, new value
# example: update_property_in_file MYFLAG FILENAME true
update_property_in_file() {
  local property="${1}"
  local filename="${2}"
  local value="${3}"
  if [ -f "$filename" ]; then
  local ispresent=`grep "^${property}" "$filename"`
  if [ -n "$ispresent" ]; then
      # first escape the pipes new value so we can use it with replacement command, which uses pipe | as the separator
      local escaped_value=`echo "${value}" | sed 's/|/\\|/g'`
      # replace just that line in the file and save the file
      updatedcontent=`sed -re "s|^(${property})\s*=\s*(.*)|\1=${escaped_value}|" "${filename}"`
      # protect against an error
      if [ -n "$updatedcontent" ]; then
        echo "$updatedcontent" > "${filename}"
      else
        echo_warning "Cannot write $property to $filename with value: $value"
        echo -n 'sed -re "s|^('
        echo -n "${property}"
        echo -n ')=(.*)|\1='
        echo -n "${escaped_value}"
        echo -n '|" "'
        echo -n "${filename}"
        echo -n '"'
        echo
      fi
  else
      # property is not already in file so add it. extra newline in case the last line in the file does not have a newline
      echo "" >> "${filename}"
      echo "${property}=${value}" >> "${filename}"
  fi
  # test
  else
    # file does not exist so create it
    echo "${property}=${value}" > "${filename}"
  fi
}


### FUNCTION LIBRARY: package management

# TODO  replace all the other yum|rpm|...*detect
# with one function like package_manager_detect() that 
# detects all of them. then only one function needs to be
# called at the beginning and the results can be used
# any time.
# package_manager_detect() { ... }

# RedHat and CentOS may have yum and rpm

# Output:
# - variable "yum" contains path to yum or empty
yum_detect() {
  yum=`which yum 2>/dev/null`
}
# Output:
# - variable "rpm" contains path to rpm or empty
rpm_detect() {
  rpm=`which rpm 2>/dev/null`
}

# Debian and Ubuntu may have apt-get and dpkg
# Output:
# - variable "aptget" contains path to apt-get or empty
# - variable "aptcache" contains path to apt-cache or empty
aptget_detect() {
  aptget=`which apt-get 2>/dev/null`
  aptcache=`which apt-cache 2>/dev/null`
}
# Output:
# - variable "dpkg" contains path to dpkg or empty
dpkg_detect() {
  dpkg=`which dpkg 2>/dev/null`
}

# SUSE has yast
# Output:
# - variable "yast" contains path to yast or empty
yast_detect() {
  yast=`which yast 2>/dev/null`
}

# SUSE has zypper
# Output:
# - variable "zypper" contains path to zypper or empty
zypper_detect() {
  zypper=`which zypper 2>/dev/null`
}

# Parameters:
# - absolute path to startup script to register
# - the name to use in registration (one word)
register_startup_script() {
  local absolute_filename="${1}"
  local startup_name="${2}"

  # try to install it as a startup script
  if [ -d /etc/init.d ]; then
    local prevdir=`pwd`
    cd /etc/init.d
    if [ -f "${startup_name}" ]; then rm -f "${startup_name}"; fi
    ln -s "${absolute_filename}" "${startup_name}"
    cd "$prevdir"
  fi

  # RedHat
  chkconfig=`which chkconfig  2>/dev/null`
  if [ -n "$chkconfig" ]; then
    $chkconfig --add "${startup_name}"  2>/dev/null
  fi

  # Ubuntu
  updatercd=`which update-rc.d  2>/dev/null`
  if [ -n "$updatercd" ]; then
    $updatercd "${startup_name}" defaults  2>/dev/null
  fi

}

# Ensure the package actually needs to be installed before calling this function.
# takes arguments: component name (string), package list prefix (string)
auto_install() {
  local component=${1}
  local cprefix=${2}
  local yum_packages=$(eval "echo \$${cprefix}_YUM_PACKAGES")
  local apt_packages=$(eval "echo \$${cprefix}_APT_PACKAGES")
  local yast_packages=$(eval "echo \$${cprefix}_YAST_PACKAGES")
  local zypper_packages=$(eval "echo \$${cprefix}_ZYPPER_PACKAGES")
  # detect available package management tools. start with the less likely ones to differentiate.
  yum_detect; yast_detect; zypper_detect; rpm_detect; aptget_detect; dpkg_detect;
  if [[ -n "$zypper" && -n "$zypper_packages" ]]; then
        zypper install $zypper_packages
  elif [[ -n "$yast" && -n "$yast_packages" ]]; then
        yast -i $yast_packages
  elif [[ -n "$yum" && -n "$yum_packages" ]]; then
        yum -y install $yum_packages
  elif [[ -n "$aptget" && -n "$apt_packages" ]]; then
        apt-get -y install $apt_packages
  fi
}

# this was used in setup.sh when we installed complete rpm or deb packages via the self-extracting installer.
# not currently used, but will be used again when we return to rpm and deb package descriptors
# in conjunction with the self-extracting installer 
my_service_install() {
  auto_install "Application requirements" "APPLICATION"
  if [[ -n "$dpkg" && -n "$aptget" ]]; then
    is_installed=`$dpkg --get-selections | grep "${package_name_deb}" | awk '{ print $1 }'`
    if [ -n "$is_installed" ]; then
      echo "Looks like ${package_name} is already installed. Cleaning..."
      $dpkg -P ${is_installed}
    fi
    echo "Installing $DEB_PACKAGE"
    $dpkg -i $DEB_PACKAGE
    $aptget -f install
  elif [[ -n "$rpm" && -n "$yum" ]]; then
    is_installed=`$rpm -qa | grep "${package_name_rpm}"`
    if [ -n "$is_installed" ]; then
      echo "Looks like ${package_name} is already installed. Cleaning..."
      $rpm -e ${is_installed}
    fi
    echo "Installing $RPM_PACKAGE"
    $rpm -i $RPM_PACKAGE
  fi
  $package_setup_cmd
}

### FUNCTION LIBRARY: NETWORK INFORMATION

# Echo all the localhost's non-loopback IP addresses
# Parameters: None
# Output:
#   The output of "ifconfig" will be scanned for any non-loopback address and all results will be echoed
hostaddress_list() {
  # if you want to exclude certain categories, such as 192.168, add this after the 127.0.0.1 exclusion:  grep -v "^192.168." 
  ifconfig | grep "inet addr" | awk '{ print $2 }' | awk -F : '{ print $2 }' | grep -v "127.0.0.1"
}


# Echo localhost's non-loopback IP address
# Parameters: None
# Output:
#   If the environment variable HOSTADDRESS exists and has a value, its value will be used (careful to make sure it only has one addres!).
#   Otherwise If the file /etc/ipaddress exists, the first line of its content will be echoed. This allows a system administrator to "override" the output of this function for the localhost.
#   Otherwise the output of "ifconfig" will be scanned for any non-loopback address and the first one will be used.
hostaddress() {
  if [ -n "$HOSTADDRESS" ]; then
    echo "$HOSTADDRESS"
  elif [ -s /etc/ipaddress ]; then
    cat /etc/ipaddress | head -n 1
  else
    # if you want to exclude certain categories, such as 192.168, add this after the 127.0.0.1 exclusion:  grep -v "^192.168." 
    local HOSTADDRESS=`hostaddress_list | head -n 1`
    echo "$HOSTADDRESS"
  fi
}



### FUNCTION LIBRARY: SSH FUNCTIONS

# Displays the fingerprints of all ssh host keys on this server
ssh_fingerprints() {
  local has_ssh_keygen=`which ssh-keygen 2>/dev/null`
  if [ -z "$has_ssh_keygen" ]; then echo_warning "missing program: ssh-keygen"; return; fi
  local ssh_pubkeys=`find /etc -name ssh_host_*.pub`
  for file in $ssh_pubkeys
  do
    local keybits=`ssh-keygen -lf "$file" | awk '{ print $1 }'`
    local keyhash=`ssh-keygen -lf "$file" | awk '{ print $2 }'`
    local keytype=`ssh-keygen -lf "$file" | awk '{ print $4 }' | tr -d '()'`
    echo "$keyhash ($keytype-$keybits)"
  done
}


### FUNCTION LIBRARY: MYSQL FUNCTIONS


# parameters:
# 1. path to properties file
# 2. properties prefix (for mountwilson.as.db.user etc. the prefix is mountwilson.as.db)
# the default prefix is "mysql" for properties like "mysql.user", etc. The
# prefix must not have any spaces or special shell characters
mysql_read_connection_properties() {
    local config_file="$1"
    local prefix="${2:-mysql}"
    MYSQL_HOSTNAME=`read_property_from_file ${prefix}.host "${config_file}"`
    MYSQL_PORTNUM=`read_property_from_file ${prefix}.port "${config_file}"`
    MYSQL_USERNAME=`read_property_from_file ${prefix}.user "${config_file}"`
    MYSQL_PASSWORD=`read_property_from_file ${prefix}.password "${config_file}"`
    MYSQL_DATABASE=`read_property_from_file ${prefix}.schema "${config_file}"`
}
mysql_write_connection_properties() {
    local config_file="$1"
    local prefix="${2:-mysql}"
    update_property_in_file ${prefix}.host "${config_file}" "${MYSQL_HOSTNAME}"
    update_property_in_file ${prefix}.port "${config_file}" "${MYSQL_PORTNUM}"
    update_property_in_file ${prefix}.user "${config_file}" "${MYSQL_USERNAME}"
    update_property_in_file ${prefix}.password "${config_file}" "${MYSQL_PASSWORD}"
    update_property_in_file ${prefix}.schema "${config_file}" "${MYSQL_DATABASE}"
}

# parameters:
# - configuration filename (absolute path)
# - property prefix for settings in the configuration file (java format is assumed, dot will be automatically appended to prefix)
mysql_userinput_connection_properties() {
    echo "Configuring MySQL Connection..."
    prompt_with_default MYSQL_HOSTNAME "Hostname:" ${DEFAULT_MYSQL_HOSTNAME}
    prompt_with_default MYSQL_PORTNUM "Port Num:" ${DEFAULT_MYSQL_PORTNUM}
    prompt_with_default MYSQL_DATABASE "Database:" ${DEFAULT_MYSQL_DATABASE}
    prompt_with_default MYSQL_USERNAME "Username:" ${DEFAULT_MYSQL_USERNAME}
    prompt_with_default_password MYSQL_PASSWORD "Password:" ${DEFAULT_MYSQL_PASSWORD}
}

mysql_clear() {
  MYSQL_HOME=""
  mysql=""
}

# Environment:
# - mysql_required_version (or provide it as a parameter)
mysql_version() {
  local min_version="${1:-${mysql_required_version}}"
  MYSQL_CLIENT_VERSION=""
  MYSQL_CLIENT_VERSION_OK=""
  if [ -n "$mysql" ]; then
    MYSQL_CLIENT_VERSION=`$mysql --version | sed -e 's/^.*Distrib \([0-9.]*\).*$/\1/g;'`
    MYSQL_CLIENT_VERSION_OK=`is_version_at_least "$MYSQL_CLIENT_VERSION" "${min_version}"`
  fi
}

# Environment:
# - mysql_required_version
mysql_version_report() {
  mysql_version
  if [ "$MYSQL_CLIENT_VERSION_OK" == "yes" ]; then
    echo_success "Mysql client version $MYSQL_CLIENT_VERSION is ok"
  else
    echo_warning "Mysql client version $MYSQL_CLIENT_VERSION is not supported, minimum is ${mysql_required_version}"
  fi
}

# Environment:
# - mysql_required_version
mysql_detect() {
  local min_version="${1:-${mysql_required_version}}"
  if [[ -n "$MYSQL_HOME" && -n "$mysql" && -f "$mysql" ]]; then
    return
  fi
  mysql=`which mysql 2>/dev/null`
  if [ -e "$mysql" ]; then
    MYSQL_HOME=`dirname $mysql`
    echo "Found mysql client: $mysql"
    mysql_version ${min_version}
    if [ "$MYSQL_CLIENT_VERSION_OK" != "yes" ]; then
  MYSQL_HOME=''
  mysql=""
    fi
  fi
}


mysql_server_detect() {
  if [[ -n "$mysqld" && -f "$mysqld" ]]; then
    return 0
  fi
  if [[ -f /sbin/service && -f /etc/init.d/mysqld ]]; then
    mysqld="service mysqld"
    echo "Found mysql server: $mysqld"
    return 0
  fi
  if [[ -f /usr/bin/mysqld_safe ]]; then
    mysqld="/usr/bin/mysqld_safe"
    echo "Found mysql server: $mysqld"
    return 0
  fi
  mysqld=`which mysqld_safe 2>/dev/null`
  if [[ -f "$mysqld" ]]; then
    echo "Found mysql server: $mysqld"
    return 0
  fi
  return 1
}


# must load from config file or call mysql_detect prior to calling this function
mysql_env_report() {
  echo "mysql=$mysql"
}

# Environment:
# - mysql_required_version
mysql_require() {
  local min_version="${1:-${mysql_required_version}}"
  if [[ -z "$MYSQL_HOME" || -z "$mysql" || ! -f "$mysql" ]]; then
    mysql_detect ${min_version} > /dev/null
  fi
  if [[ -z "$MYSQL_HOME" || -z "$mysql" || ! -f "$mysql" ]]; then
    echo "Cannot find MySQL client version $min_version or later"
    exit 1
  fi
}



# Environment:
# - mysql_required_version
mysql_connection() {
  mysql_require
  mysql_connect="$mysql --batch --host=${MYSQL_HOSTNAME:-$DEFAULT_MYSQL_HOSTNAME} --port=${MYSQL_PORTNUM:-$DEFAULT_MYSQL_PORTNUM} --user=${MYSQL_USERNAME:-$DEFAULT_MYSQL_USERNAME} --password=${MYSQL_PASSWORD:-$DEFAULT_MYSQL_PASSWORD}"
}

# Environment:
# - mysql_required_version
# sets the is_mysql_available variable to "yes" or ""
# sets the is_MYSQL_DATABASE_created variable to "yes" or ""
mysql_test_connection() {
  mysql_connection
  is_mysql_available=""
  local mysql_test_result=`$mysql_connect -e "show databases" 2>/tmp/intel.mysql.err | grep "^${MYSQL_DATABASE}\$" | wc -l`
  if [ $mysql_test_result -gt 0 ]; then
    is_mysql_available="yes"
  fi
  mysql_connection_error=`cat /tmp/intel.mysql.err`
  rm -f /tmp/intel.mysql.err
}

# Environment:
# - mysql_required_version
mysql_test_connection_report() {
  echo -n "Testing database connection... "
  mysql_test_connection
  if [ -n "$is_mysql_available" ]; then
    echo "OK"
  else
    echo "FAILED"
    echo_failure "${mysql_connection_error}"
  fi
}


# Environment:
# - mysql_required_version
# installs mysql client programs (not the server)
# we need the mysql client to create or patch the database, but
# the server can be installed anywhere
mysql_install() {
  MYSQL_CLIENT_YUM_PACKAGES="mysql"
  MYSQL_CLIENT_APT_PACKAGES="mysql-client"
  mysql_detect > /dev/null
  if [[ -z "$MYSQL_HOME" || -z "$mysql" ]]; then
    auto_install "MySQL client" "MYSQL_CLIENT" >> $INSTALL_LOG_FILE
    if [[ -z "$MYSQL_HOME" || -z "$mysql" ]]; then
      echo_failure "Unable to auto-install MySQL client" | tee -a $INSTALL_LOG_FILE
      echo "MySQL download URL:" &>> $INSTALL_LOG_FILE
      echo "http://www.mysql.com/downloads/" >> $INSTALL_LOG_FILE
    fi
  else
    echo "MySQL client is already installed" >> $INSTALL_LOG_FILE
  fi
}

# Environment:
# - mysql_required_version
# installs mysql server 
mysql_server_install() {
  MYSQL_SERVER_YUM_PACKAGES="mysql-server"
  MYSQL_SERVER_APT_PACKAGES="mysql-server"
  mysql_server_detect >> $INSTALL_LOG_FILE
  if [[ -n "$mysqld" ]]; then
    echo "MySQL server is already installed" >> $INSTALL_LOG_FILE
    return;
  fi
  if [[ -z "$mysqld" ]]; then
    auto_install "MySQL server" "MYSQL_SERVER"   >> $INSTALL_LOG_FILE
    mysql_server_detect
  fi
  if [[ -z "$mysqld" ]]; then
    MYSQL_SERVER_YUM_PACKAGES=""
    MYSQL_SERVER_APT_PACKAGES="mysql-server-5.5"
    auto_install "MySQL server" "MYSQL_SERVER"  >> $INSTALL_LOG_FILE
    mysql_server_detect
  fi
  if [[ -z "$mysqld" ]]; then
    MYSQL_SERVER_YUM_PACKAGES=""
    MYSQL_SERVER_APT_PACKAGES="mysql-server-5.1"
    auto_install "MySQL server" "MYSQL_SERVER"  >> $INSTALL_LOG_FILE
    mysql_server_detect
  fi
  if [[ -z "$mysqld" ]]; then
    echo_failure "Unable to auto-install MySQL server" | tee -a $INSTALL_LOG_FILE
    echo "MySQL download URL:"  >> $INSTALL_LOG_FILE
    echo "http://www.mysql.com/downloads/" >> $INSTALL_LOG_FILE
  fi
}

# responsible for ensuring that the connection properties in the config file
# Call this from the control script such as "asctl" before calling the other mysql_* functions
# Parameters:
# - absolute path to configuration file
# - prefix of mysql property file names (java style, dot is added automatically)
# Environment:
# - script_name such as 'asctl' or 'wlmctl'
# - intel_conf_dir (deprecated, just use absolute package_config_filename)
# - package_config_filename  (should be absolute)
mysql_configure_connection() {
    local config_file="${1:-/etc/intel/cloudsecurity/mysql.properties}"
    local prefix="${2:-mysql}"
    mysql_test_connection
    if [ -z "$is_mysql_available" ]; then
      mysql_read_connection_properties "${config_file}" "${prefix}"
      mysql_test_connection
    fi
    while [ -n "$mysql_connection_error" ]
    do
      echo_warning "Cannot connect to MySQL: $mysql_connection_error"
      prompt_yes_no MYSQL_RETRY_CONFIGURE_AFTER_FAILURE "Do you want to configure it now?"
      if [[ "no" == "$MYSQL_RETRY_CONFIGURE_AFTER_FAILURE" ]]; then
        echo "MySQL settings are in ${package_config_filename}"
        echo "Run '${script_name} setup' after configuring to continue."
        return 1
      fi
      mysql_userinput_connection_properties
      mysql_test_connection
    done
      echo_success "Connected to database \`${MYSQL_DATABASE}\` on ${MYSQL_HOSTNAME}"
#      local should_save
#      prompt_yes_no should_save "Save in ${package_config_filename}?"
#      if [[ "yes" == "${should_save}" ]]; then
        mysql_write_connection_properties "${config_file}" "${prefix}"
#      fi
}


# requires a mysql connection that can access the existing database, OR (if it doesn't exist)
# requires a mysql connection that can create databases and grant privileges
# call mysql_configure_connection before calling this function
mysql_create_database() {
  mysql_test_connection
  local create_sql="CREATE DATABASE \`${MYSQL_DATABASE}\`;"
  local grant_sql="GRANT ALL ON \`${MYSQL_DATABASE}\`.* TO \`${MYSQL_USERNAME}\` IDENTIFIED BY '${MYSQL_PASSWORD}';"
  if [ -z "$mysql_connection_error" ]; then
    if [ -n "$is_mysql_available" ]; then
      echo_success "Database \`${MYSQL_DATABASE}\` already exists"   >> $INSTALL_LOG_FILE
      return 0
    else
      echo "Creating database..."    >> $INSTALL_LOG_FILE
      $mysql_connect -e "${create_sql}"
      $mysql_connect -e "${grant_sql}"
      mysql_test_connection
      if [ -z "$is_mysql_available" ]; then
        echo_failure "Failed to create database."  | tee -a $INSTALL_LOG_FILE
        return 1
      fi
    fi
  else
    echo_failure "Cannot connect to database."  | tee -a $INSTALL_LOG_FILE
    echo "Try to execute the following commands on the database:"  >> $INSTALL_LOG_FILE
    echo "${create_sql}" >> $INSTALL_LOG_FILE
    echo "${grant_sql}"  >> $INSTALL_LOG_FILE
    return 1
  fi
}

# before using this function, you must first set the connection variables mysql_*
# example:  mysql_run_script /path/to/statements.sql
mysql_run_script() {
  local scriptfile="${1}"
  local datestr=`date +%Y-%m-%d.%H%M`
  echo "##### [${datestr}] Script file: ${scriptfile}" >> ${mysql_setup_log}
  $mysql_connect --force ${MYSQL_DATABASE} < "${scriptfile}" 2>> ${mysql_setup_log}
}

# requires a mysql connection that can create tables and procedures inside an existing database.
# depends on mysql_* variables for the connection information.
# call mysql_configure_connection before calling this function.
# Parameters: a list of sql files to execute (absolute paths)
mysql_install_scripts() {
  local scriptlist="$@"
  mysql_test_connection
  if [ -n "$is_mysql_available" ]; then
    echo "Connected to ${MYSQL_HOSTNAME} as ${MYSQL_USERNAME}. Executing script..."
    for scriptname in $scriptlist
    do
        mysql_run_script $scriptname
    done
    return 0
  else
    echo_failure "Cannot connect to database."
    return 1
  fi
}



mysql_running() {  
  MYSQL_SERVER_RUNNING=''
  if [ -n "$mysqld" ]; then
    local is_running=`$mysqld status | grep running`
    if [ -n "$is_running" ]; then
      MYSQL_SERVER_RUNNING=yes
    fi
  fi
}

mysql_running_report() {
  echo -n "Checking MySQL process... "
  mysql_running
  if [[ "$MYSQL_SERVER_RUNNING" == "yes" ]]; then
    echo "Running"
  else
    echo "Not running"
  fi
}
mysql_start() {
  if [ -n "$mysqld" ]; then
      $mysqld start
  fi
}
mysql_stop() {
  if [ -n "$mysqld" ]; then
      $mysqld stop
  fi
}

mysql_configure_ca() {
  export mysql_ssl_ca_dir="${1:-/etc/intel/cloudsecurity/mysql-ca}"
  # derive CA settings
  export mysql_ssl_ca_key="${mysql_ssl_ca_dir}/ca.key.pem"
  export mysql_ssl_ca_cert="${mysql_ssl_ca_dir}/ca.cert.pem"
  export mysql_ssl_ca_index="${mysql_ssl_ca_dir}/index"  
}

mysql_configure_ssl() {
  export mysql_ssl_dir="${1:-/etc/intel/cloudsecurity/mysql-ssl}"
}

# Parameters:
# - CA directory where private key, public key, and index is kept
mysql_create_ca() {
  mysql_configure_ca "${1:-$mysql_ssl_ca_dir}"
  # create CA
  if [ -f "${mysql_ssl_ca_key}" ]; then
    echo_warning "CA key already exists"
  else
    echo "Creating MySQL Certificate Authority..."
    mkdir -p "${mysql_ssl_ca_dir}"
    chmod 700 "${mysql_ssl_ca_dir}"
    touch "${mysql_ssl_ca_key}"
    chmod 600 "${mysql_ssl_ca_key}"
    openssl genrsa 2048 > "${mysql_ssl_ca_key}"
    openssl req -new -x509 -nodes -days 3650 -key "${mysql_ssl_ca_key}" -out "${mysql_ssl_ca_cert}" -subj "/CN=MySQL SSL CA/OU=Mt Wilson/O=Intel/C=US/"
    echo 0 > "${mysql_ssl_ca_index}"
  fi
}

# Parameters:
# - SSL request file (input)
# - SSL certificate file (output)
# - SSL CA dir
mysql_ca_sign() {
  local ssl_req="${1}"
  local ssl_cert="${2}"
  mysql_configure_ca "${3:-$mysql_ssl_ca_dir}"
  local prev_index next_index
  if [ -f "${mysql_ssl_ca_index}" ]; then
    prev_index=`cat "${mysql_ssl_ca_index}"`
    ((next_index=prev_index + 1))
  else
    echo_failure "Cannot find MySQL CA"
    return 1
  fi
  openssl x509 -req -in "${ssl_req}" -days 3650 -CA "${mysql_ssl_ca_cert}" -CAkey "${mysql_ssl_ca_key}"  -set_serial "${next_index}" -out "${ssl_cert}"
  echo "${next_index}" > "${mysql_ssl_ca_index}"
}

# Parameters:
# - SSL subject name (goes into the common name field in the certificate)
# - SSL directory where you keep server and client SSL keys and certificates
# - SSL CA directory
# Environment:
# you must have already created the CA key. the CA key information
# should be in the environment variables:
# MTWILSON_CA_KEY=/path/to/file
# MTWILSON_CA_CERT=/path/to/file
# MTWILSON_CA_PASSWORD=password
mysql_create_ssl() {
  local dname="${1}"
  mysql_configure_ssl "${2:-$mysql_ssl_dir}"
  mysql_configure_ca "${3:-$mysql_ssl_ca_dir}"
  echo "Creating MySQL SSL Certificate..."
  mkdir -p "${mysql_ssl_dir}"
  if [ -z "$dname" ]; then
    prompt_with_default MYSQL_SSL_CERT_CN "Common name (username):"
    dname=${MYSQL_SSL_CERT_CN}
  fi
  local filename=`echo "${dname}" | sed "s/[^a-zA-Z0-9-]/_/g"`
  local ssl_key="${mysql_ssl_dir}/${filename}.key.pem"
  local ssl_cert="${mysql_ssl_dir}/${filename}.cert.pem"
  openssl req -newkey rsa:1024 -days 3650 -nodes -keyout "${ssl_key}" -out "${ssl_cert}.req" -subj "/CN=${dname}/OU=Mt Wilson/O=Intel/C=US/"
  openssl rsa -in "${ssl_key}" -out "${ssl_key}"
  mysql_ca_sign "${ssl_cert}.req" "${ssl_cert}" "${mysql_ssl_ca_dir}"
  rm -rf "${ssl_cert}.req"
  # verify the certificate
  echo "Verifying SSL Certificate..."
  openssl verify -CAfile "${mysql_ssl_ca_cert}" "${ssl_cert}"
}

### FUNCTION LIBRARY: glassfish

glassfish_clear() {
  GLASSFISH_HOME=""
  glassfish_bin=""
  glassfish=""
}

# sets variable GLASSFISH_VERSION and GLASSFISH_VERSION_OK = yes  or  = no
# Environment:
# - glassfish_required_version
glassfish_version() {
  GLASSFISH_VERSION=""
  GLASSFISH_VERSION_OK=""
  # XXX
  echo "Checking Glassfish version for: $glassfish"
  if [ -n "$glassfish" ]; then
    GLASSFISH_VERSION=`$glassfish version 2>&1 | grep -i glassfish | grep -i version | awk '{ print $8 }'`
    GLASSFISH_VERSION_OK=`is_version_at_least "$GLASSFISH_VERSION" "${glassfish_required_version}"`
  fi
}

# Environment:
# - glassfish_required_version
glassfish_version_report() {
  glassfish_version
  if [ "$GLASSFISH_VERSION_OK" == "yes" ]; then
    echo_success "Glassfish version $GLASSFISH_VERSION is ok"
  else
    echo_warning "Glassfish version $GLASSFISH_VERSION is not supported, minimum is ${glassfish_required_version}"
  fi
}

# detects possible glassfish installations
# does nothing if GLASSFISH_HOME is already set; unset with glassfish_clear before calling to force detection
# Environment:
# - glassfish_required_version (or provide it as a parameter)
# Parameters:
# - minimum required version
glassfish_detect() {
  local min_version="${1:-${glassfish_required_version}}"
  # XXX
  echo "Looking for Glassfish $min_version"
  if [[ -n "$GLASSFISH_HOME" && -d "$GLASSFISH_HOME" ]]; then
    return
  fi
  GLASSFISH_CANDIDATES=`find / -name domains 2>/dev/null | grep glassfish/domains`
  GLASSFISH_HOME=''
  glassfish_bin=""
  glassfish=""
  # XXX
  echo "Candidates: $GLASSFISH_CANDIDATES"
  for c in $GLASSFISH_CANDIDATES
  do
    if [ -z "$GLASSFISH_HOME" ]; then
      local parent=`dirname $c`
      # XXX
      echo "Checking Glassfish: $parent"
      if [ -f "$parent/bin/asadmin" ]; then
        GLASSFISH_HOME="$parent"
        glassfish_bin="$GLASSFISH_HOME/bin/asadmin"
        # the glassfish admin tool read timeout is in milliseconds, so 900,000 is 900 seconds
        glassfish="env PATH=$java_bindir:$PATH AS_ADMIN_READTIMEOUT=900000 $glassfish_bin"
        echo "Found Glassfish: $GLASSFISH_HOME"
        glassfish_version ${min_version}
        if [ "$GLASSFISH_VERSION_OK" != "yes" ]; then
          # XXX
          echo_warning "Glassfish $parent does not meet version requirement: $min_version"
          GLASSFISH_HOME=''
          glassfish_bin=""
          glassfish=""
        fi
      fi
    fi
  done

  # read the admin username and pasword, if present. format of both files is shell  VARIABLE=VALUE
#  if [ -f /etc/glassfish/admin.user ]; then
#    export AS_ADMIN_USER=`read_property_from_file AS_ADMIN_USER /etc/glassfish/admin.user`
#  fi
#  if [ -f /etc/glassfish/admin.passwd ]; then
#    export AS_ADMIN_PASSWORDFILE=/etc/glassfish/admin.passwd
#  fi
}

# must load from config file or call glassfish_detect prior to calling this function
glassfish_env_report() {
  echo "GLASSFISH_HOME=$GLASSFISH_HOME"
  echo "glassfish_bin=$glassfish_bin"
  echo "glassfish=\"$glassfish\""
}


# Environment:
# - glassfish_required_version (or provide it as a parameter)
glassfish_require() {
  local min_version="${1:-${glassfish_required_version}}"
  if [[ -z "$GLASSFISH_HOME" || -z "$glassfish" ]]; then
    glassfish_detect ${min_version} > /dev/null
  fi
  if [[ -z "$GLASSFISH_HOME" || -z "$glassfish" ]]; then
    echo_failure "Cannot find Glassfish server version $min_version or later"
    exit 1
  fi
}

# Run this AFTER glassfish_install
# optional global variables:  
#   glassfish_username (default value glassfish)
#   GLASSFISH_HOME (default value /usr/share/glassfish3)
# works on Debian, Ubuntu, CentOS, RedHat, SUSE
# Username should not contain any spaces or punctuation
# Optional arguments:  one or more directories for glassfish user to own
glassfish_permissions() {
  local chown_locations="$@"
  local username=${glassfish_username:-glassfish}
  local user_exists=`cat /etc/passwd | grep "^${username}"`
  if [ -z "$user_exists" ]; then
    useradd -c "Glassfish" -d "${GLASSFISH_HOME:-/usr/share/glassfish3}" -r -s /bin/bash "$username"
  fi
  local file
  for file in $chown_locations
  do
    if [[ -n "$file" && -e "$file" ]]; then
      chown -R "${username}:${username}" "$file"
    fi
  done
}

# sets a system property for logback configuration file location
# requires a running glassfish
glassfish_logback() {
  # see if it's already set
  local prev_logback=`$glassfish list-system-properties 2>/dev/null | grep "logback.configurationFile"| head -n 1`
  # loop just in case there is more than one defined
#  while [ -n "${prev_logback}" ]
#  do
    echo "Deleting existing system property ${prev_logback}"
    $glassfish delete-system-property "${prev_logback}"
#    prev_logback=`$glassfish list-system-properties 2>/dev/null | grep "logback.configurationFile" | head -n 1`
#  done
  $glassfish create-system-properties logback.configurationFile=/etc/intel/cloudsecurity/logback.xml
}

# set the -Xmx and -XX:MaxPermSize memory parameters for the glassfish JVM
glassfish_memory() {
  local jvm_memory="${1:-2048}"
  local jvm_maxperm="${2:-512}"
  # glassfish must be started in order to do this
  
  # first we have to find the current options and remove them
  local prev_jvm_memory=`$glassfish list-jvm-options | grep "\-Xmx" | head -n 1`
  local prev_jvm_maxperm=`$glassfish list-jvm-options | grep "\-XX:MaxPermSize" | head -n 1`
  # loop just in case there is more than one defined
  while [ -n "${prev_jvm_memory}" ]
  do
    echo "Deleting existing option ${prev_jvm_memory}"
    $glassfish delete-jvm-options "${prev_jvm_memory}"
    prev_jvm_memory=`$glassfish list-jvm-options | grep "\-Xmx" | head -n 1`
  done
  # loop just in case there is more than one defined
  while [ -n "${prev_jvm_maxperm}" ]
  do
    # must escape the colon between XX and MaxPermSize
    prev_jvm_maxperm=`echo ${prev_jvm_maxperm} | sed -re "s/:/\\\\\\\\:/"`
    echo "Deleting existing option ${prev_jvm_maxperm}"
    $glassfish delete-jvm-options "${prev_jvm_maxperm}"
    prev_jvm_maxperm=`$glassfish list-jvm-options | grep "\-XX:MaxPermSize" | head -n 1`
  done
  $glassfish create-jvm-options "-Xmx${jvm_memory}m:-XX\\:MaxPermSize=${jvm_maxperm}m"
}

# reset glassfish overall logging handler to turn on logging
# this is required because glassfish 3.1.1 and later...
#  UI has a bug that causes the
# logging handler to be set to OFF whenever a user saves any change to
# other logging levels. 
# references:
# http://java.net/jira/browse/GLASSFISH-17037
# http://stackoverflow.com/questions/9373629/glassfish-3-1-1-suddenly-stopped-writing-to-server-log
glassfish_enable_logging() {
  $glassfish set-log-levels com.sun.enterprise.server.logging.GFFileHandler=ALL
}

# must restart glassfish for enable-secure-admin and memory options to take effect, so call these after calling this function:
#  glassfish_stop
#  glassfish_start
# (they are not done automatically in case the caller has other glassfish setup that would also require a restart)
# Environment:
# - glassfish_required_version
glassfish_install() {
  local GLASSFISH_PACKAGE="${1:-glassfish.zip}"
  GLASSFISH_YUM_PACKAGES="unzip"
  GLASSFISH_APT_PACKAGES="unzip"
  glassfish_detect

  glassfish_running
  if [[ -n "$GLASSFISH_RUNNING" ]]; then
    glassfish_stop
  fi

  if [[ -z "$GLASSFISH_HOME" || -z "$glassfish" ]]; then
    if [ -d /usr/share/glassfish3 ]; then
      # we do not remove it automatically in case there are applications or data in there that the user wants to save!!
      echo_warning "Glassfish not detected but /usr/share/glassfish3 exists"
      echo "Remove /usr/share/glassfish3 and try again"
      return 1
    fi
    if [[ -z "$GLASSFISH_PACKAGE" || ! -f "$GLASSFISH_PACKAGE" ]]; then
      echo_failure "Missing Glassfish installer: $GLASSFISH_PACKAGE"
      return 1
    fi
    auto_install "Glassfish requirements" "GLASSFISH"
    echo "Installing $GLASSFISH_PACKAGE"
    unzip $GLASSFISH_PACKAGE 2>&1  >/dev/null
    mv glassfish3 /usr/share/
    # Glassfish requires hostname to be mapped to 127.0.0.1 in /etc/hosts
    if [ -f "/etc/hosts" ]; then
        local hostname=`hostname`
        local found=`cat "/etc/hosts" | grep "^127.0.0.1" | grep "$hostname"`
        if [ -z "$found" ]; then
          local datestr=`date +%Y-%m-%d.%H%M`
          cp /etc/hosts /etc/hosts.${datestr}
          local updated=`sed -re "s/^(127.0.0.1\s.*)$/\1 ${hostname}/" /etc/hosts`
          echo "$updated" > /etc/hosts
        fi
    fi
    glassfish_detect
    if [[ -z "$GLASSFISH_HOME" || -z "$glassfish" ]]; then
      echo_failure "Unable to auto-install Glassfish"
      echo "Glassfish download URL:"
      echo "http://glassfish.java.net/"
      return 1
    fi
  else
    echo "Glassfish is already installed in $GLASSFISH_HOME"
  fi

  # TODO this functionality is moving to the java tool ; completely remove it from here
  #if [ -n "${MTWILSON_SERVER}" ]; then
  #  glassfish_create_ssl_cert "${MTWILSON_SERVER}"
  #else
  #  glassfish_create_ssl_cert_prompt
  #fi

  glassfish_permissions "${GLASSFISH_HOME}"
  glassfish_start
  #glassfish_admin_user
  glassfish_memory 2048 512
  glassfish_logback
}

# glassfish must already be running to execute "enable-secure-domain",  so glassfish_start is required before calling this function
glassfish_admin_user() {  
  echo "You must choose an administrator username and password for Glassfish"
  echo "The Glassfish control panel is at https://${MTWILSON_SERVER:-127.0.0.1}:4848"
  prompt_with_default AS_ADMIN_USER "Glassfish admin username:"
  export AS_ADMIN_USER
  prompt_with_default_password AS_ADMIN_PASSWORD "Glassfish admin password:"

  export AS_ADMIN_PASSWORDFILE=/etc/glassfish/admin.passwd
  mkdir -p /etc/glassfish
  touch /etc/glassfish/admin.user /etc/glassfish/admin.passwd /etc/glassfish/admin.passwd.old
  chmod 600 /etc/glassfish/admin.user /etc/glassfish/admin.passwd /etc/glassfish/admin.passwd.old
  echo "AS_ADMIN_USER=${AS_ADMIN_USER}" > /etc/glassfish/admin.user
  echo "AS_ADMIN_PASSWORD=${AS_ADMIN_PASSWORD}" > /etc/glassfish/admin.passwd
  echo "AS_ADMIN_PASSWORD=" > /etc/glassfish/admin.passwd.old
  #echo "AS_ADMIN_MASTERPASSWORD=changeit" >> /etc/glassfish/admin.passwd

  echo "Glassfish will now ask you for the same information:"
  # $glassfish is an alias for full path of asadmin
  $glassfish --user=admin --passwordfile=/etc/glassfish/admin.passwd.old change-admin-password
  # XXX it asks for the password twice ...  can we script with our known value?
  $glassfish --user=admin --passwordfile=/etc/glassfish/admin.passwd enable-secure-admin

}

glassfish_running() {  
  GLASSFISH_RUNNING=''
  if [ -n "$GLASSFISH_HOME" ]; then
    GLASSFISH_PID=`ps gauwxx | grep java | grep -v grep | grep "$GLASSFISH_HOME" | awk '{ print $2 }'`
    if [ -n "$GLASSFISH_PID" ]; then
      GLASSFISH_RUNNING=yes
    fi
  fi
}

glassfish_running_report() {
  echo -n "Checking Glassfish process... "
  glassfish_running
  if [ -n "$GLASSFISH_PID" ]; then
    echo "Running (pid $GLASSFISH_PID)"
  else
    echo "Not running"
  fi
}
glassfish_start() {
  if [ -n "$glassfish" ]; then
      $glassfish start-domain
  fi
}
glassfish_stop() {
  if [ -n "$glassfish" ]; then
      $glassfish stop-domain
  fi
}
glassfish_restart() {
  if [ -n "$glassfish" ]; then
      $glassfish restart-domain
  fi
}
glassfish_shutdown() {
  glassfish_running
  if [ -n "$GLASSFISH_PID" ]; then
      kill -9 $GLASSFISH_PID
  fi
}
glassfish_start_report() {
  action_condition GLASSFISH_RUNNING "Starting Glassfish" "glassfish_start > /dev/null; glassfish_running;"
}

# Must call java_require before calling this.
# Parameters:
# - certificate alias to report on (default is s1as, the glassfish default ssl cert alias)
glassfish_sslcert_report() {
  local alias="${1:-s1as}"
  local keystorePassword=changeit
  local domain_found=`$glassfish list-domains | head -n 1 | awk '{ print $1 }'`
  local keystore=${GLASSFISH_HOME}/domains/${domain_found}/config/keystore.jks
  java_keystore_cert_report "$keystore" "$keystorePassword" "$alias"
}

# used by attestation_service_install to create a new domain just for attestation service
# parameters:  domain name, domain dir (absolute path)
# example: glassfish_create_domain "intel-as" "${ATTESTATION_SERVICE_HOME}/glassfish/domain"
# TODO ??? if attestation-service is configured to be deployed into a specific domain instead of
# the default domain, then we should define glassfish commands that abstract it so that
# the attestatioN_service_start/stop  don't need to really know that. 
# TODO !!! the create-domain command outputs the following lines which we need to capture so
# we can know the URL's for the new domain:
#
#Default port 4848 for Admin is in use. Using 39766
#Default port 8080 for HTTP Instance is in use. Using 41112
#Default port 7676 for JMS is in use. Using 52108
#Default port 3700 for IIOP is in use. Using 46322
#Default port 8181 for HTTP_SSL is in use. Using 42364
#
glassfish_create_domain() {
  local domain_name=${1}
  local domain_dir=${2}
  if [ -n "$glassfish" ]; then
    $glassfish create-domain --domaindir "${domain_dir}" "${domain_name}"
    $glassfish start-domain --domaindir "${domain_dir}" "${domain_name}"
  fi
}

# ??? see comment below about deleting the domain dir.  MAYBE the answer is
# to not provide a domain deletion command at all???? just create the domain if
# it does not exist and if it does install into it and we never delete the domain
# or its log files. OR, on uninstall we can delete the domain but just let the
# log files stay and sysadmin will have to clean that up if he wants to reinstall???
# or better to just undeploy the app on uninstall and leave the domain alone. 
glassfish_delete_domain() {
  local domain_name=${1}
  local domain_dir=${2}
  if [ -n "$glassfish" ]; then
    local domain_found=`$glassfish list-domains --domaindir "${domain_dir}" | grep "${domain_name}"`
    if [ -n "$domain_found" ]; then
      $glassfish delete-domain --domaindir "${domain_dir}" "${domain_name}"
      # TODO !!! after a domain is running there is a server.log file in the domain directory,
      # and the delete-domain command deletes everything except the log files... and if there is any
      # file still in the domain directory then a subsequent create-domain command will fail. so 
      # we need to delete the domain_dir/domain_name folder completely. but since this script will
      # probably be run as root, we want to be sure that we don't accidentally rm -rf /  or /opt etc.
      # SO, we need to check that domain_name is not blank and that domain_dir is not blank or just "/"...
      # but don't even try to do that manually because we'll miss something, like "/.././" 
      #rm -rf "${domain_dir}/${domain_name}"
    fi
  fi
}

glassfish_create_ssl_cert_prompt() {
    echo_warning "This feature has been disabled: glassfish_create_ssl_cert_prompt"
    return
    # SSL Certificate setup
    #local should_create_sslcert
    prompt_yes_no GLASSFISH_CREATE_SSL_CERT "Do you want to set up an SSL certificate for Glassfish?"
    echo
    if [ "${GLASSFISH_CREATE_SSL_CERT}" == "yes" ]; then
      java_require
      glassfish_require
      local ssl_domain
      echo -n "Domain name for SSL Certificate [127.0.0.1]: "
      read ssl_domain
      ssl_domain=${ssl_domain:-"127.0.0.1"}
      glassfish_create_ssl_cert "${ssl_domain}"
    fi
}

# TODO this functionality is moving to the java tool ; completely remove it from here
# Parameters:
# - serverName (hostname in the URL, such as 127.0.0.1, 192.168.1.100, my.attestation.com, etc.)
# XXX this function assumes we're using the first glassfish domain... usually "domain1"
glassfish_create_ssl_cert() {
  echo_warning "This feature has been disabled: glassfish_create_ssl_cert"
  return
  java_require
  glassfish_require
  local serverName="${1}"
  local keystorePassword=changeit
  local domain_found=`$glassfish list-domains | head -n 1 | awk '{ print $1 }'`
  local keystore=${GLASSFISH_HOME}/domains/${domain_found}/config/keystore.jks
  local keytool=${JAVA_HOME}/bin/keytool
  local mtwilson=`which mtwilson 2>/dev/null`
  # does the keystore already have a cert with this alias? the alias has to be s1as (too much work to change it) so we check to see if a separate certificate file has been saved, indicating that s1as has already been replaced.
  #local ssl_found=`$keytool -list -keystore $keystore -storepass $keystorePassword | grep PrivateKeyEntry | awk -F ',' '{ print $1 }' | grep ${serverName}`
  #if [ -n "$ssl_found" ]; then
  #if [ -f "${GLASSFISH_HOME}/domains/${domain_found}/config/ssl.${serverName}.crt" ]; then
  #  echo "SSL Certificate for ${serverName} already exists"
  # Check if there is already a certificate for this serverName in the Glassfish keystore
  local has_cert=`$keytool -list -v -alias s1as -keystore $keystore -storepass $keystorePassword | grep "^Owner:" | grep "CN=${serverName}"`
  if [ -n "$has_cert" ]; then
    echo "SSL Certificate for ${serverName} already exists"
  else
    echo "Creating SSL Certificate for ${serverName}..."
    $keytool -delete -alias s1as  -keystore $keystore -storepass $keystorePassword
    # NIARL code in Trust Agent uses Bouncy Castle APIs which require a Subject Alternative Name in the Server's SSL certificate in order to validate a certificate with an IP address in the subject.
    # Java 7 supports -ext san=ip:1.2.3.4    to add the extension.  Java 6 does not.  So we use the mtwilson command to generate it. 
    #$keytool -genkey -alias s1as -keysize 2048 -keyalg RSA -dname "CN=${serverName}, OU=Mt Wilson, C=US" -keystore $keystore -storepass $keystorePassword -keypass $keystorePassword -validity 3650
    #$mtwilson api CreateSSLCertificate "CN=${serverName}, OU=Mt Wilson, C=US" "ip:${serverName}" $keystore s1as "$keystorePassword"
    $mtwilson api CreateSSLCertificate "${serverName}" "ip:${serverName}" $keystore s1as "$keystorePassword"
    $keytool -export -alias s1as -file "${GLASSFISH_HOME}/domains/${domain_found}/config/ssl.${serverName}.crt" -keystore $keystore -storepass $keystorePassword 
    echo "Restarting Glassfish domain..."
    glassfish_restart
  fi
}

### FUNCTION LIBRARY: tomcat

# tomcat 

tomcat_clear() {
  TOMCAT_HOME=""
  tomcat_bin=""
  tomcat=""
}

# sets variable TOMCAT_VERSION and TOMCAT_VERSION_OK = yes  or  = no
tomcat_version() {
  TOMCAT_VERSION=""
  TOMCAT_VERSION_OK=""
  if [ -n "$tomcat" ]; then
    TOMCAT_VERSION=`$tomcat version 2>&1 | grep -i "Server version:" | awk -F / '{ print $2 }'`
    TOMCAT_VERSION_OK=`is_version_at_least "$TOMCAT_VERSION" "${tomcat_required_version}"`
  fi
}

tomcat_version_report() {
  tomcat_version
  if [ "$TOMCAT_VERSION_OK" == "yes" ]; then
    echo "Tomcat version $TOMCAT_VERSION is ok"
  else
    echo "Tomcat version $TOMCAT_VERSION is not supported, minimum is ${tomcat_required_version}"
  fi
}

# detects possible tomcat installations
# does nothing if TOMCAT_HOME is already set; unset before calling to force detection
tomcat_detect() {
  if [[ -n "$TOMCAT_HOME" && -d "$TOMCAT_HOME" ]]; then
    return
  fi
  TOMCAT_CANDIDATES=`find ${tomcat_parent_dir} -name tomcat-users.xml`
  TOMCAT_HOME=''
  tomcat_bin=""
  tomcat=""
  for c in $TOMCAT_CANDIDATES
  do
    if [ -z "$TOMCAT_HOME" ]; then
      local bin_dir=`dirname $c`
      local parent=`dirname $bin_dir`
      if [ -f "$parent/bin/catalina.sh" ]; then
        TOMCAT_HOME="$parent"
        tomcat_bin="$TOMCAT_HOME/bin/catalina.sh"
        tomcat="env PATH=$java_bindir:$PATH JAVA_HOME=$JAVA_HOME CATALINA_HOME=$TOMCAT_HOME $tomcat_bin"
        echo "Found Tomcat: $TOMCAT_HOME"
        tomcat_version
        if [ "$TOMCAT_VERSION_OK" != "yes" ]; then
          TOMCAT_HOME=''
          tomcat_bin=""
          tomcat=""
        fi
      fi
    fi
  done
}


tomcat_install() {
  #TOMCAT_YUM_PACKAGES="unzip"
  #TOMCAT_APT_PACKAGES="unzip"
  #auto_install "Tomcat requirements" "TOMCAT"
  tomcat_detect
  if [[ -z "$TOMCAT_HOME" || -z "$tomcat" ]]; then
    if [[ -n "$TOMCAT_PACKAGE" && -f "$TOMCAT_PACKAGE" ]]; then
        echo "Installing $TOMCAT_PACKAGE"
        if [ -d "${tomcat_parent_dir}/${tomcat_name}" ]; then
          local datestr=`date +%Y-%m-%d.%H%M`
          echo "Renaming existing incomplete ${tomcat_parent_dir}/${tomcat_name} to ${tomcat_parent_dir}/${tomcat_name}.${datestr}"
          mv $tomcat_parent_dir/$tomcat_name $tomcat_parent_dir/${tomcat_name}.${datestr}
      fi
      gunzip -c $TOMCAT_PACKAGE | tar xf - 2>&1  >/dev/null
      #local tomcat_folder=`echo $TOMCAT_PACKAGE | awk -F .tgz '{ print $1 }'`
      #mv $tomcat_folder $tomcat_parent_dir/$tomcat_name
      mv $tomcat_name $tomcat_parent_dir/
      # Glassfish requires hostname to be mapped to 127.0.0.1 in /etc/hosts; leaving this in for Tomcat for now until we know that it's not required
      if [ -f "/etc/hosts" ]; then
        local hostname=`hostname`
        local found=`cat "/etc/hosts" | grep "^127.0.0.1" | grep "$hostname"`
        if [ -z "$found" ]; then
          local datestr=`date +%Y-%m-%d.%H%M`
          cp /etc/hosts /etc/hosts.${datestr}
          local updated=`sed -re "s/^(127.0.0.1\s.*)$/\1 ${hostname}/" /etc/hosts`
          echo "$updated" > /etc/hosts
        fi
      fi
            
    fi
  fi
  tomcat_detect
  if [[ -z "$TOMCAT_HOME" || -z "$tomcat" ]]; then
    echo "Unable to auto-install Tomcat"
    echo "  Tomcat download URL:"
    echo "  http://tomcat.apache.org/"
  fi
}

### FUNCTION LIBRARY: java

java_clear() {
  JAVA_HOME=""
  java=""
}

# checks if the version of the currently configured java meets the minimum
# requirement. if not, then it resets the java variables.
# Environment:
# - java_required_version (or pass it as a parameter)
java_version() {
  local min_version="${1:-${java_required_version}}"
  JAVA_VERSION=""
  JAVA_VERSION_OK=""
  if [ -n "$java" ]; then
    # extract the version number from a string like: java version "1.6.0_29"
    JAVA_VERSION=`$java -version 2>&1 | head -n 1 | sed -e 's/"//g' | awk '{ print $3 }'`
    JAVA_VERSION_OK=`is_java_version_at_least "$JAVA_VERSION" "${min_version}"`
  fi
  if [ "$JAVA_VERSION_OK" != "yes" ]; then
    JAVA_HOME=''
    java=""
  fi
}

# Environment:
# - java_required_version
java_version_report() {
  java_version
  if [ "$JAVA_VERSION_OK" == "yes" ]; then
    echo_success "Java version $JAVA_VERSION is ok"
  else
    echo_warning "Java version $JAVA_VERSION is not supported, minimum is ${java_required_version}"
    JAVA_HOME=''
    java=""
  fi
}


# detects possible java installations
# does nothing if JAVA_HOME is already set; unset before calling to force detection
# uses the first installation found that meets the version requirement.
# prefers JDK over JRE installations, and prefers JRE over system-provided java
# This is not because JDK is better than JRE is better than system-provided java,
# but because if the system administrator has bothered to install the JDK or JRE
# it's clear he prefers to use that over the system-provided java.
# Environment:
# - java_required_version
java_detect() {
  local min_version="${1:-${java_required_version}}"
  if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
    JAVA_JDK_CANDIDATES=`find / -name java 2>/dev/null | grep jdk | grep -v jre | grep bin/java`
    for c in $JAVA_JDK_CANDIDATES
    do
      if [[ -z "$JAVA_HOME" ]]; then
        java_bindir=`dirname $c`
        if [ -f "$java_bindir/java" ]; then
          JAVA_HOME=`dirname $java_bindir`
          java=$c
          echo "Found Java: $JAVA_HOME"
          java_version ${min_version}
        fi
      fi
    done
  fi
  if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
    echo "Cannot find JDK"
    JAVA_JRE_CANDIDATES=`find / -name java 2>/dev/null | grep jre | grep bin/java`
    for c in $JAVA_JRE_CANDIDATES
    do
      if [[ -z "$JAVA_HOME" ]]; then
        java_bindir=`dirname $c`
        if [ -f "$java_bindir/java" ]; then
          JAVA_HOME=`dirname $java_bindir`
          java=$c
          echo "Found Java: $JAVA_HOME"
          java_version ${min_version}
        fi
      fi
    done
  fi
  if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
    echo "Cannot find JRE"
    JAVA_BIN_CANDIDATES=`find / -name java 2>/dev/null | grep bin/java`
    for c in $JAVA_BIN_CANDIDATES
    do
      if [[ -z "$JAVA_HOME" ]]; then
        java_bindir=`dirname $c`
        # in non-JDK and non-JRE folders the "java" command may be a symlink:
        if [ -f "$java_bindir/java" ]; then
          JAVA_HOME=`dirname $java_bindir`
          java=$c
          echo "Found Java: $c"
          java_version ${min_version}
        elif [ -h "$java_bindir/java" ]; then
          local javatarget=`readlink $c`
          if [ -f "$javatarget" ]; then
            java_bindir=`dirname $javatarget`
            JAVA_HOME=`dirname $java_bindir`
            java=$javatarget
            echo "Found Java: $java"
            java_version ${min_version}
          else
            echo "Broken link $c -> $javatarget"
          fi
        fi
      fi
    done
  fi
}

# must load from config file or call java_detect prior to calling this function
java_env_report() {
  echo "JAVA_HOME=$JAVA_HOME"
  echo "java_bindir=$java_bindir"
  echo "java=$java"
}

# Environment:
# - java_required_version in the format "1.6.0_29" (or pass it as a parameter)
java_require() {
  local min_version="${1:-${java_required_version}}"
  if [[ -z "$JAVA_HOME" || -z "$java" || ! -f "$java" ]]; then
    java_detect ${min_version} > /dev/null
  fi
  if [[ -z "$JAVA_HOME" || -z "$java" || ! -f "$java" ]]; then
    echo_failure "Cannot find Java version $java_required_version or later"
    exit 1
  fi
}

# Environment:
# - java_required_version in the format "1.6.0_29"
java_install_openjdk() {
  JAVA_YUM_PACKAGES="java-1.6.0-openjdk java-1.6.0-openjdk-devel"
  JAVA_APT_PACKAGES="openjdk-6-jre openjdk-6-jdk"
  java_detect
  if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
    auto_install "Java" "JAVA"
    java_detect
    if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
      echo_failure "Cannot install Java"
      echo "Java download URL:"
      echo "http://www.java.com/en/download/"
    fi
  else
    echo "Java is already installed"
  fi
}

java_install() {
  local JAVA_PACKAGE="${1-:jdk-6u29-linux-x64.bin}"
#  JAVA_YUM_PACKAGES="java-1.6.0-openjdk java-1.6.0-openjdk-devel"
#  JAVA_APT_PACKAGES="openjdk-6-jre openjdk-6-jdk"
#  auto_install "Java" "JAVA"
  java_clear; java_detect >> $INSTALL_LOG_FILE; java_version;
  if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
    if [[ -z "$JAVA_PACKAGE" || ! -f "$JAVA_PACKAGE" ]]; then
      echo_failure "Missing Java installer: $JAVA_PACKAGE" | tee -a 
      return 1
    fi
    local javafile=$JAVA_PACKAGE
    echo "Installing $javafile"  >> $INSTALL_LOG_FILE
    is_gzip=`echo $javafile | grep ".gz$"`
    is_bin=`echo $javafile | grep ".bin$"`
    javaname=`echo $javafile | awk -F . '{ print $1 }'`
    if [ -n "$is_gzip" ]; then
      gunzip $javafile 2>&1 >/dev/null  >> $INSTALL_LOG_FILE
      chmod +x $javaname
      ./$javaname | grep -vE "inflating:|creating:|extracting:|linking:|^Creating" 
    elif [ -n "$is_bin" ]; then
      chmod +x $javafile
      ./$javafile | grep -vE "inflating:|creating:|extracting:|linking:|^Creating"  
    fi
    # java gets unpacked in current directory but they cleverly
    # named the folder differently than the archive, so search for it:
    local java_unpacked=`ls -1d jdk* jre* 2>/dev/null`
    for f in $java_unpacked
    do
      #echo "$f"
      if [ -d "$f" ]; then
        mv "$f" /usr/share
      fi
    done
    java_detect  >> $INSTALL_LOG_FILE
    if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
      echo_failure "Unable to auto-install Java" | tee -a $INSTALL_LOG_FILE
      echo "  Java download URL:"                >> $INSTALL_LOG_FILE
      echo "  http://www.java.com/en/download/"  >> $INSTALL_LOG_FILE
    fi
  else
    echo "Java is already installed"              >> $INSTALL_LOG_FILE
  fi
}

java_keystore_cert_report() {
  local keystore="${1:-keystore.jks}"
  local keystorePassword="${2:-changeit}"
  local alias="${3:-s1as}"
  local keytool=${JAVA_HOME}/bin/keytool
  local owner_expires=`$keytool -list -v -alias $alias -keystore $keystore -storepass $keystorePassword | grep -E "^Owner|^Valid"`
  echo "$owner_expires"
  local fingerprints=`$keytool -list -v -alias $alias -keystore $keystore -storepass $keystorePassword | grep -E "MD5:|SHA1:"`
  echo "$fingerprints"
}


### FUNCTION LIBARARY: prerequisites reporting


# environment dependencies report
print_env_summary_report() {
  echo "Requirements summary:"
  local error=0
  if [ -n "$JAVA_HOME" ]; then
    echo "Java: $JAVA_VERSION"
  else
    echo_failure "Java: not found"
    error=1
  fi
  if using_mysql; then
    if [ -n "$MYSQL_HOME" ]; then
      echo "Mysql: $MYSQL_CLIENT_VERSION"
    else
      echo_failure "Mysql: not found"
      error=1
    fi
  fi
  if using_postgres; then
    echo_warning "Postgres: relying on existing install"
  fi
  if using_glassfish; then
    if [ -n "$GLASSFISH_HOME" ]; then
      echo "Glassfish: $GLASSFISH_VERSION"
    else
      echo_failure "Glassfish: not found"
      error=1
    fi
  fi
  if using_tomcat; then
    echo_warning "Tomcat: relying on existing install"
  fi
  return $error
}


### FUNCTION LIBRARY: web service on top of glassfish

# parameters: glassfish_application_name such as "AttestationService"
webservice_running() {
  local glassfish_application_name="$1"
  glassfish_running
  WEBSERVICE_RUNNING=""
  if [ -n "$GLASSFISH_RUNNING" ]; then
    # TODO ??? check for the specific ATTESTATION_SERVICE_ID name defined in ${intel_conf_dir}/${package_env_filename}
    WEBSERVICE_DEPLOYED=`$glassfish list-applications | grep "${glassfish_application_name}" | head -n 1 | awk '{ print $1 }'`
    if [ -n "$WEBSERVICE_DEPLOYED" ]; then
      WEBSERVICE_RUNNING=`$glassfish show-component-status $WEBSERVICE_DEPLOYED | grep enabled`
    fi
  fi
}
webservice_running_report() {
  local glassfish_application_name="$1"
  echo -n "Checking ${glassfish_application_name}... "
  webservice_running "${glassfish_application_name}"
  if [ -n "$WEBSERVICE_RUNNING" ]; then
    echo "Running"
  else
    echo "Not running"
  fi
}


webservice_start() {
  local glassfish_application_name="$1"
  webservice_running  "${glassfish_application_name}"
  if [ -n "$WEBSERVICE_DEPLOYED" ]; then
    $glassfish enable $WEBSERVICE_DEPLOYED
  fi
}
webservice_stop() {
  local glassfish_application_name="$1"
  webservice_running "${glassfish_application_name}"
  if [ -n "$WEBSERVICE_DEPLOYED" ]; then
    $glassfish disable $WEBSERVICE_DEPLOYED
  fi
}

webservice_start_report() {
    local glassfish_application_name="$1"
    glassfish_require
    glassfish_running
    if [ -z "$GLASSFISH_RUNNING" ]; then
        glassfish_start_report
    fi    
    webservice_running "${glassfish_application_name}"
    if [ -z "$WEBSERVICE_RUNNING" ]; then
          action_condition WEBSERVICE_RUNNING "Starting ${glassfish_application_name}" "webservice_start ${glassfish_application_name} > /dev/null; webservice_running ${glassfish_application_name};"
    fi
    if [ -n "$WEBSERVICE_RUNNING" ]; then
          echo_success "${glassfish_application_name} is running"
    fi
}
webservice_stop_report() {
    local glassfish_application_name="$1"
    glassfish_require
    glassfish_running
    webservice_running "${glassfish_application_name}"
    if [ -n "$GLASSFISH_RUNNING" ]; then
      if [ -n "$WEBSERVICE_RUNNING" ]; then
        inaction_condition WEBSERVICE_RUNNING "Stopping ${glassfish_application_name}" "webservice_stop ${glassfish_application_name} > /dev/null; webservice_running ${glassfish_application_name};"
      fi
    fi
    if [ -z "$WEBSERVICE_RUNNING" ]; then
      echo_success "${glassfish_application_name} is stopped"
    fi
}


# parameters:
# glassfish_application_name such as "AttestationService"
# webservice_war_file such as "/path/to/AttestationService-0.5.1.war"
# Environment:
# - glassfish_required_version
webservice_install() {
  local glassfish_application_name="$1"
  local webservice_war_file="$2"
  glassfish_require
  #glassfish_create_domain "intel-as" "${ATTESTATION_SERVICE_HOME}/glassfish/domain"
  webservice_running "${glassfish_application_name}"
#  local WAR_NAME=${ATTESTATION_SERVICE_ID}
#  local WAR_FILE=${ATTESTATION_SERVICE_ID}.war
  local WAR_FILE="${webservice_war_file}"
    if [ -n "$WEBSERVICE_DEPLOYED" ]; then
      echo "Re-deploying ${WEBSERVICE_DEPLOYED} to Glassfish..."
      ${glassfish} redeploy --name ${WEBSERVICE_DEPLOYED} ${WAR_FILE}
    else
      echo "Deploying ${glassfish_application_name} to Glassfish..."
      ${glassfish} deploy --name ${glassfish_application_name} ${WAR_FILE}
    fi
}

webservice_uninstall() {
  local glassfish_application_name="$1"
  webservice_running "${glassfish_application_name}"
#  local WAR_NAME=${ATTESTATION_SERVICE_ID}
  local WAR_NAME="${glassfish_application_name}"
  if [ -n "$WEBSERVICE_DEPLOYED" ]; then
    echo "Undeploying ${WEBSERVICE_DEPLOYED} from Glassfish..."
    ${glassfish} undeploy ${WEBSERVICE_DEPLOYED}
  else
    echo "Application is not deployed on Glassfish; skipping undeploy"
  fi
}

