#!/bin/bash
# WARNING:
# *** do NOT use TABS for indentation, use SPACES
# *** TABS will cause errors in some linux distributions

# CONFIGURATION:

# TERM_DISPLAY_MODE can be "plain" or "color"
TERM_DISPLAY_MODE=color
TERM_STATUS_COLUMN=60
TERM_COLOR_GREEN="\\033[1;32m"
TERM_COLOR_RED="\\033[1;31m"
TERM_COLOR_YELLOW="\\033[1;33m"
TERM_COLOR_NORMAL="\\033[0;39m"


DEFAULT_MYSQL_HOSTNAME="127.0.0.1"
DEFAULT_MYSQL_PORTNUM="3306"
DEFAULT_MYSQL_USERNAME="root"
DEFAULT_MYSQL_PASSWORD=""
DEFAULT_MYSQL_DATABASE="mw_as"

DEFAULT_POSTGRES_HOSTNAME="127.0.0.1"
DEFAULT_POSTGRES_PORTNUM="5432"
DEFAULT_POSTGRES_USERNAME="root"
DEFAULT_POSTGRES_PASSWORD=""
DEFAULT_POSTGRES_DATABASE="mw_as"

DEFAULT_JAVA_REQUIRED_VERSION="1.6"
DEFAULT_GLASSFISH_REQUIRED_VERSION="3.0"
DEFAULT_TOMCAT_REQUIRED_VERSION="6.0"

DEFAULT_MTWILSON_API_BASEURL="http://127.0.0.1:"
DEFAULT_TOMCAT_API_PORT="8443"
DEFAULT_GLASSFISH_API_PORT="8181"
#DEFAULT_API_PORT=$DEFAULT_GLASSFISH_API_PORT

export INSTALL_LOG_FILE=/tmp/mtwilson-install.log

### FUNCTION LIBRARY: terminal display functions

# move to column 60:    term_cursor_movex $TERM_STATUS_COLUMN
# Environment:
# - TERM_DISPLAY_MODE
term_cursor_movex() {
  local x="$1"
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then
    echo -en "\\033[${x}G"
  fi
}

# Environment:
# - TERM_DISPLAY_MODE
# - TERM_DISPLAY_GREEN
# - TERM_DISPLAY_NORMAL
echo_success() {
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_GREEN}"; fi
  echo ${@:-"[  OK  ]"}
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  return 0
}

# Environment:
# - TERM_DISPLAY_MODE
# - TERM_DISPLAY_RED
# - TERM_DISPLAY_NORMAL
echo_failure() {
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_RED}"; fi
  echo ${@:-"[FAILED]"}
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  return 1
}

# Environment:
# - TERM_DISPLAY_MODE
# - TERM_DISPLAY_YELLOW
# - TERM_DISPLAY_NORMAL
echo_warning() {
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo ${@:-"[WARNING]"}
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  return 1
}

### SHELL FUNCTIONS

# parameters: space-separated list of files to include (shell functions or configuration)
# example:  shell_include_files /path/to/file1 /path/to/file2 /path/to/file3 ...
# if any file does not exist, it is skipped
shell_include_files() {
  for filename in "$@"
  do
    if [ -f "${filename}" ]; then
      . ${filename}
    fi
  done
}


### FUNCTION LIBRARY: information functions

# Runs its argument and negates the error code: 
# If the argument exits with success (0) then this function exits with error (1).
# If the argument exits with error (1) then this function exits with success (0).
# Note: only works with arguments that are executable; any additional parameters will be passed.
# Example:  if not using_java; then echo "Warning: skipping Java"; fi 
no() { $* ; if [ $? -eq 0 ]; then return 1; else return 0; fi }
not() { $* ; if [ $? -eq 0 ]; then return 1; else return 0; fi }

# extracts the major version number (1) out of a string like 1.2.3_4
version_major() {
  echo "${1}" | awk -F . '{ print $1 }'
}
# extracts the minor version number (2) out of a string like 1.2.3_4
version_minor() {
  echo "${1}" | awk -F . '{ print $2 }'
}
# extracts the second minor version number (3) out of a string like 1.2.3_4
version_extract3() {
  local thirdpart=`echo "${1}" | awk -F . '{ print $3 }'`
  echo "${thirdpart}" | awk -F _ '{ print $1 }'
}
# extracts the fourth minor version number (4) out of a string like 1.2.3_4
version_extract4() {
  local thirdpart=`echo "${1}" | awk -F . '{ print $3 }'`
  echo "${thirdpart}" | awk -F _ '{ print $2 }'
}

# two arguments: actual version number (string), required version number (string)
# example:  `is_version_at_least 4.9 5.0` will return "no" because 4.9 < 5.0
is_version_at_least() {
  local testver="${1}"
  local reqver="${2}"
  local hasmajor=`version_major "${testver}"`
  local hasminor=`version_minor "${testver}"`
  local reqmajor=`version_major "${reqver}"`
  local reqminor=`version_minor "${reqver}"`
  if [[  -n "${reqmajor}" && "${hasmajor}" -gt "${reqmajor}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -z "${reqminor}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -n "${reqminor}" && "${hasminor}" -ge "${reqminor}" \
     ]]; then
    echo "yes"
    return 0
  else
    echo "no"
    return 1
  fi  
}

# like is_version_at_least but works on entire java version string 1.6.0_29
# instead of just a major.minor number
# Parameters:
# - version to test (of installed software)
# - minimum required version
# Return code:  0 (no errors) if the java version given is greater than or equal to the minimum version
is_java_version_at_least() {
  local testver="${1}"
  local reqver="${2}"
  local hasmajor=`version_major "${testver}"`
  local hasminor=`version_minor "${testver}"`
  local hasminor3=`version_extract3 "${testver}"`
  local hasminor4=`version_extract4 "${testver}"`
  local reqmajor=`version_major "${reqver}"`
  local reqminor=`version_minor "${reqver}"`
  local reqminor3=`version_extract3 "${reqver}"`
  local reqminor4=`version_extract4 "${reqver}"`
  if [[  -n "${reqmajor}" && "${hasmajor}" -gt "${reqmajor}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -z "${reqminor}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -n "${reqminor}" && "${hasminor}" -gt "${reqminor}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}" \
       && -n "${reqminor3}" && "${hasminor3}" -gt "${reqminor3}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}" \
       && -z "${reqminor3}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}" \
       && -n "${reqminor3}" && "${hasminor3}" -eq "${reqminor3}" \
       && -z "${reqminor4}" \
     || \
       -n "${reqmajor}" && "${hasmajor}" -eq "${reqmajor}" \
       && -n "${reqminor}"  && "${hasminor}"  -eq "${reqminor}" \
       && -n "${reqminor3}" && "${hasminor3}" -eq "${reqminor3}" \
       && -n "${reqminor4}" && "${hasminor4}" -ge "${reqminor4}"  \
     ]]; then
#    echo "yes"
    return 0
  else
#    echo "no"
    return 1
  fi  
}

# Parameters:
# - variable name to set with result
# - prompt (string)
# will accept y, Y, or nothing as yes, anything else as no
prompt_yes_no() {
  local resultvarname="${1}"
  local userprompt="${2}"
  # bug #512 add support for answer file
  if [ -n "${!resultvarname}" ]; then
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
    echo "$userprompt [Y/n] ${!resultvarname}"
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
    return
  fi
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo -n "$userprompt [Y/n] "
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  local userinput
  read -n 1 userinput
  echo
  if [[ $userinput == "Y" || $userinput == "y" || $userinput == "" ]]; then
    eval $resultvarname="yes"
  else
    eval $resultvarname="no"
  fi
}

# Parameters:
# - character like 'a' for which to echo the character code
# echos the character code of the specified character
# For example:   ord a     will echo 97
ord() { printf '%d' "'$1"; }

# Parameters:
# - variable name to set with result
# - prompt text (include any punctuation such as ? or : you want to display)
# - default setting (do not include any brackets or punctuation). 
#   If the default setting is omitted, the current value of the output variable name will be used.
# Output:
# - result (input or default) is saved into the specified variable name
#
# Examples:
#   prompt_with_default USERNAME "What is your name?"
#   prompt_with_default USERCOLOR "What is your favorite color?" ${DEFAULT_COLOR}
prompt_with_default() {
  local resultvarname="${1}"
  local userprompt="${2}"
  local default_value
  eval default_value="${3:-\$$resultvarname}"
  # bug #512 add support for answer file
  if [ -n "${!resultvarname}" ]; then
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
    echo "$userprompt [$default_value] ${!resultvarname:-$default_value}"
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
    return
  fi
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo -n "$userprompt [$default_value] "
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  local userinput
  read userinput
  eval $resultvarname=${userinput:-$default_value}
}

# Same as prompt_with_default, but the default value is hidden by *******,
# and if prompt text is not provided then the default prompt is "Password:"
prompt_with_default_password() {
  local resultvarname="${1}"
  local userprompt="${2:-Password:}"
  local default_value
  eval default_value="${3:-\$$resultvarname}"
  local default_value_display="********"
  # bug #512 add support for answer file
  if [ -n "${!resultvarname}" ]; then
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
    echo "$userprompt [$default_value_display] ${default_value_display}"
    if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
    return
  fi
  if [ -z "$default_value" ]; then default_value_display=""; fi;
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_YELLOW}"; fi
  echo -n "$userprompt [$default_value_display] "
  if [ "$TERM_DISPLAY_MODE" = "color" ]; then echo -en "${TERM_COLOR_NORMAL}"; fi
  local userinput=""
  #IFS= read -r -s userinput
  #echo
  local input_counter=0
  local char
  while IFS= read -r -s -n 1 char
  do
    local code=`ord $char`
    if [[ $char == $'\0' ]]; then
      break
    elif [[ "$code" == "8" || "$code" == "127" ]]; then
      if (($input_counter > 0)); then
        echo -n $'\b \b';
        ((input_counter--))
        userinput="${userinput%?}"
      fi
    else
      echo -n '*'
      userinput+="$char";
      ((input_counter++))
    fi
  done
  echo
  eval $resultvarname=${userinput:-$default_value}
}

### FUNCTION LIBRARY: environment information functions

# Usage example:   if using_glassfish; then echo "Using glassfish"; fi
using_glassfish() { if [[ "${WEBSERVER_VENDOR}" == "glassfish" ]]; then return 0; else return 1; fi }
using_tomcat() { if [[ "${WEBSERVER_VENDOR}" == "tomcat" ]]; then return 0; else return 1; fi }
using_mysql() { if [[ "${DATABASE_VENDOR}" == "mysql" ]]; then return 0; else return 1; fi }
using_postgres() { if [[ "${DATABASE_VENDOR}" == "postgres" ]]; then return 0; else return 1; fi }
 
### FUNCTION LIBARRY: conditional execution functions

# TODO: rename to positive_condition
# parameters: condition variable name, status line, code to run
# Will print "status line... " and then "OK" or "FAILED"
action_condition() {
  local condvar="${1}"
  local statusline="${2}"
  local condfn="${3}"
  local cond=$(eval "echo \$${condvar}")
  echo -n "$statusline"
  echo -n "... "
  if [ -n "$cond" ]; then
    echo_success "Skipped"
  else # if [ -z "$cond" ]; then
    eval "$condfn"
    cond=$(eval "echo \$${condvar}")
    if [ -n "$cond" ]; then
      echo_success "OK"
    else
      echo_failure "FAILED"
    fi
  fi
}
# TODO: rename to negative_condition
# similar to action_condition but reverses the logic: empty is OK, defined is FAILED
inaction_condition() {
  local condvar="${1}"
  local statusline="${2}"
  local condfn="${3}"
  local cond=$(eval "echo \$${condvar}")
  echo -n "$statusline"
  echo -n "... "
  if [ -z "$cond" ]; then
    echo_success "Skipped"
  else # if [ -z "$cond" ]; then
    eval "$condfn"
    cond=$(eval "echo \$${condvar}")
    if [ -z "$cond" ]; then
      echo_success "OK"
    else
      echo_failure "FAILED"
    fi
  fi
}

### FUNCTION LIBRARY: file management

# parameter: one or more paths to check for existence
# output: the first entry found to exist
# example:
# mybinary=`first_existing /usr/local/bin/ahctl /usr/bin/ahctl /opt/local/bin/ahctl /opt/bin/ahctl /opt/intel/cloudsecurity/attestation-service/bin/ahctl`
first_existing() {
    local search_locations="$@"
    local file
    for file in $search_locations
    do
      if [[ -e "$file" ]]; then
        echo "$file"
        return 0
      fi
    done
    return 1
}

# parameters: one or more files/directories to check for existence
# return value: returns 0 if all files are present, 1 if any are missing; displays report on screen
# example:
# report_files_exist /etc/file1 /etc/file2
report_files_exist() {
    local search_locations="$@"
    local report_summary=0
    local file
    for file in $search_locations
    do
      if [[ -e "$file" ]]; then
        echo_success "$file" exists
      else
        echo_failure "$file" missing
        report_summary=1
      fi
    done
    return $report_summary
}

# makes a date-stamped backup copy of a file
backup_file() {
  local filename="${1}"
  local datestr=`date +%Y-%m-%d.%H%M`
  local backup_filename="${filename}.${datestr}"
  if [[ -n "$filename" && -f "$filename" ]]; then
    cp ${filename} ${backup_filename}
    echo "${backup_filename}"
  fi
}

# read a property from a property file formatted like NAME=VALUE
# parameters: property name, filename
# example: read_property_from_file MYFLAG FILENAME
# Automatically strips Windows carriage returns from the file
read_property_from_file() {
  local property="${1}"
  local filename="${2}"
  if [ -f "$filename" ]; then
    local found=`cat "$filename" | grep "^$property"`
    if [ -n "$found" ]; then
      #echo -n `cat "$filename" | tr -d '\r' | grep "^$property" | tr -d '\n' | awk -F '=' '{ print $2 }'`
      echo `cat "$filename" | tr -d '\r' | grep "^$property" | head -n 1 | awk -F '=' '{ print $2 }'`
    fi
  fi
}

# write a property into a property file, replacing the previous value
# parameters: property name, filename, new value
# example: update_property_in_file MYFLAG FILENAME true
update_property_in_file() {
  local property="${1}"
  local filename="${2}"
  local value="${3}"
  if [ -f "$filename" ]; then
  local ispresent=`grep "^${property}" "$filename"`
  if [ -n "$ispresent" ]; then
      # first escape the pipes new value so we can use it with replacement command, which uses pipe | as the separator
      local escaped_value=`echo "${value}" | sed 's/|/\\|/g'`
      # replace just that line in the file and save the file
      updatedcontent=`sed -re "s|^(${property})\s*=\s*(.*)|\1=${escaped_value}|" "${filename}"`
      # protect against an error
      if [ -n "$updatedcontent" ]; then
        echo "$updatedcontent" > "${filename}"
      else
        echo_warning "Cannot write $property to $filename with value: $value"
        echo -n 'sed -re "s|^('
        echo -n "${property}"
        echo -n ')=(.*)|\1='
        echo -n "${escaped_value}"
        echo -n '|" "'
        echo -n "${filename}"
        echo -n '"'
        echo
      fi
  else
      # property is not already in file so add it. extra newline in case the last line in the file does not have a newline
      echo "" >> "${filename}"
      echo "${property}=${value}" >> "${filename}"
  fi
  # test
  else
    # file does not exist so create it
    echo "${property}=${value}" > "${filename}"
  fi
}

configure_api_baseurl() {
  # setup mtwilson.api.baseurl
  local config_file="${1:-/etc/intel/cloudsecurity/my.properties}" 
  
  local input_api_baseurl
  if [ -n "${MTWILSON_API_BASEURL}" ]; then
    mtwilson_api_baseurl="${MTWILSON_API_BASEURL}"
  elif [ -n "${MTWILSON_SERVER}" ]; then
    mtwilson_api_baseurl="https://${MTWILSON_SERVER}:$DEFAULT_API_PORT"
  else
    local configured_api_baseurl=`read_property_from_file mtwilson.api.baseurl "${config_file}"`
    prompt_with_default input_api_baseurl "Mt Wilson Server (IP, Hostname, or URL):" "${configured_server_url}"
    
    if [[ "$input_api_baseurl" == http* ]]; then
      mtwilson_api_baseurl="$input_api_baseurl"
    else
      mtwilson_api_baseurl="https://${input_api_baseurl}:$DEFAULT_API_PORT"
    fi
  fi
  export MTWILSON_API_BASEURL=$mtwilson_api_baseurl
  update_property_in_file mtwilson.api.baseurl "${config_file}" "${mtwilson_api_baseurl}"
}

### FUNCTION LIBRARY: package management

# TODO  replace all the other yum|rpm|...*detect
# with one function like package_manager_detect() that 
# detects all of them. then only one function needs to be
# called at the beginning and the results can be used
# any time.
# package_manager_detect() { ... }

# RedHat and CentOS may have yum and rpm

# Output:
# - variable "yum" contains path to yum or empty
yum_detect() {
  yum=`which yum 2>/dev/null`
  if [ -n "$yum" ]; then return 0; else return 1; fi
}
no_yum() {
  if yum_detect; then return 1; else return 0; fi
}

# Output:
# - variable "rpm" contains path to rpm or empty
rpm_detect() {
  rpm=`which rpm 2>/dev/null`
}

# Debian and Ubuntu may have apt-get and dpkg
# Output:
# - variable "aptget" contains path to apt-get or empty
# - variable "aptcache" contains path to apt-cache or empty
aptget_detect() {
  aptget=`which apt-get 2>/dev/null`
  aptcache=`which apt-cache 2>/dev/null`
}
# Output:
# - variable "dpkg" contains path to dpkg or empty
dpkg_detect() {
  dpkg=`which dpkg 2>/dev/null`
}

# SUSE has yast
# Output:
# - variable "yast" contains path to yast or empty
yast_detect() {
  yast=`which yast 2>/dev/null`
}

# SUSE has zypper
# Output:
# - variable "zypper" contains path to zypper or empty
zypper_detect() {
  zypper=`which zypper 2>/dev/null`
}

# Parameters:
# - absolute path to startup script to register
# - the name to use in registration (one word)
register_startup_script() {
  local absolute_filename="${1}"
  local startup_name="${2}"

  # try to install it as a startup script
  if [ -d /etc/init.d ]; then
    local prevdir=`pwd`
    cd /etc/init.d
    if [ -f "${startup_name}" ]; then rm -f "${startup_name}"; fi
    ln -s "${absolute_filename}" "${startup_name}"
    cd "$prevdir"
  fi

  # RedHat
  chkconfig=`which chkconfig  2>/dev/null`
  if [ -n "$chkconfig" ]; then
    $chkconfig --add "${startup_name}"  2>/dev/null
  fi

  # Ubuntu
  updatercd=`which update-rc.d  2>/dev/null`
  if [ -n "$updatercd" ]; then
    $updatercd "${startup_name}" defaults  2>/dev/null
  fi

}

# Ensure the package actually needs to be installed before calling this function.
# takes arguments: component name (string), package list prefix (string)
auto_install() {
  local component=${1}
  local cprefix=${2}
  local yum_packages=$(eval "echo \$${cprefix}_YUM_PACKAGES")
  local apt_packages=$(eval "echo \$${cprefix}_APT_PACKAGES")
  local yast_packages=$(eval "echo \$${cprefix}_YAST_PACKAGES")
  local zypper_packages=$(eval "echo \$${cprefix}_ZYPPER_PACKAGES")
  # detect available package management tools. start with the less likely ones to differentiate.
  yum_detect; yast_detect; zypper_detect; rpm_detect; aptget_detect; dpkg_detect;
  if [[ -n "$zypper" && -n "$zypper_packages" ]]; then
        zypper install $zypper_packages
  elif [[ -n "$yast" && -n "$yast_packages" ]]; then
        yast -i $yast_packages
  elif [[ -n "$yum" && -n "$yum_packages" ]]; then
        yum -y install $yum_packages
  elif [[ -n "$aptget" && -n "$apt_packages" ]]; then
        apt-get -y install $apt_packages
  fi
}

# this was used in setup.sh when we installed complete rpm or deb packages via the self-extracting installer.
# not currently used, but will be used again when we return to rpm and deb package descriptors
# in conjunction with the self-extracting installer 
my_service_install() {
  auto_install "Application requirements" "APPLICATION"
  if [[ -n "$dpkg" && -n "$aptget" ]]; then
    is_installed=`$dpkg --get-selections | grep "${package_name_deb}" | awk '{ print $1 }'`
    if [ -n "$is_installed" ]; then
      echo "Looks like ${package_name} is already installed. Cleaning..."
      $dpkg -P ${is_installed}
    fi
    echo "Installing $DEB_PACKAGE"
    $dpkg -i $DEB_PACKAGE
    $aptget -f install
  elif [[ -n "$rpm" && -n "$yum" ]]; then
    is_installed=`$rpm -qa | grep "${package_name_rpm}"`
    if [ -n "$is_installed" ]; then
      echo "Looks like ${package_name} is already installed. Cleaning..."
      $rpm -e ${is_installed}
    fi
    echo "Installing $RPM_PACKAGE"
    $rpm -i $RPM_PACKAGE
  fi
  $package_setup_cmd
}

### FUNCTION LIBRARY: NETWORK INFORMATION

# Echo all the localhost's non-loopback IP addresses
# Parameters: None
# Output:
#   The output of "ifconfig" will be scanned for any non-loopback address and all results will be echoed
hostaddress_list() {
  # if you want to exclude certain categories, such as 192.168, add this after the 127.0.0.1 exclusion:  grep -v "^192.168." 
  ifconfig | grep "inet addr" | awk '{ print $2 }' | awk -F : '{ print $2 }' | grep -v "127.0.0.1"
}


# Echo localhost's non-loopback IP address
# Parameters: None
# Output:
#   If the environment variable HOSTADDRESS exists and has a value, its value will be used (careful to make sure it only has one addres!).
#   Otherwise If the file /etc/ipaddress exists, the first line of its content will be echoed. This allows a system administrator to "override" the output of this function for the localhost.
#   Otherwise the output of "ifconfig" will be scanned for any non-loopback address and the first one will be used.
hostaddress() {
  if [ -n "$HOSTADDRESS" ]; then
    echo "$HOSTADDRESS"
  elif [ -s /etc/ipaddress ]; then
    cat /etc/ipaddress | head -n 1
  else
    # if you want to exclude certain categories, such as 192.168, add this after the 127.0.0.1 exclusion:  grep -v "^192.168." 
    local HOSTADDRESS=`hostaddress_list | head -n 1`
    echo "$HOSTADDRESS"
  fi
}



### FUNCTION LIBRARY: SSH FUNCTIONS

# Displays the fingerprints of all ssh host keys on this server
ssh_fingerprints() {
  local has_ssh_keygen=`which ssh-keygen 2>/dev/null`
  if [ -z "$has_ssh_keygen" ]; then echo_warning "missing program: ssh-keygen"; return; fi
  local ssh_pubkeys=`find /etc -name ssh_host_*.pub`
  for file in $ssh_pubkeys
  do
    local keybits=`ssh-keygen -lf "$file" | awk '{ print $1 }'`
    local keyhash=`ssh-keygen -lf "$file" | awk '{ print $2 }'`
    local keytype=`ssh-keygen -lf "$file" | awk '{ print $4 }' | tr -d '()'`
    echo "$keyhash ($keytype-$keybits)"
  done
}


### FUNCTION LIBRARY: MYSQL FUNCTIONS


# parameters:
# 1. path to properties file
# 2. properties prefix (for mountwilson.as.db.user etc. the prefix is mountwilson.as.db)
# the default prefix is "mysql" for properties like "mysql.user", etc. The
# prefix must not have any spaces or special shell characters
mysql_read_connection_properties() {
    local config_file="$1"
    local prefix="${2:-mysql}"
    MYSQL_HOSTNAME=`read_property_from_file ${prefix}.host "${config_file}"`
    MYSQL_PORTNUM=`read_property_from_file ${prefix}.port "${config_file}"`
    MYSQL_USERNAME=`read_property_from_file ${prefix}.user "${config_file}"`
    MYSQL_PASSWORD=`read_property_from_file ${prefix}.password "${config_file}"`
    MYSQL_DATABASE=`read_property_from_file ${prefix}.schema "${config_file}"`
}
mysql_write_connection_properties() {
    local config_file="$1"
    local prefix="${2:-mysql}"
    update_property_in_file ${prefix}.host "${config_file}" "${MYSQL_HOSTNAME}"
    update_property_in_file ${prefix}.port "${config_file}" "${MYSQL_PORTNUM}"
    update_property_in_file ${prefix}.user "${config_file}" "${MYSQL_USERNAME}"
    update_property_in_file ${prefix}.password "${config_file}" "${MYSQL_PASSWORD}"
    update_property_in_file ${prefix}.schema "${config_file}" "${MYSQL_DATABASE}"
    update_property_in_file ${prefix}.driver "${config_file}" "com.mysql.jdbc.Driver"
    # if you create a .url property then it takes precedence over the .host, .port, and .schema - so let user do that
}

# parameters:
# - configuration filename (absolute path)
# - property prefix for settings in the configuration file (java format is assumed, dot will be automatically appended to prefix)
mysql_userinput_connection_properties() {
    echo "Configuring MySQL Connection..."
    prompt_with_default MYSQL_HOSTNAME "Hostname:" ${DEFAULT_MYSQL_HOSTNAME}
    prompt_with_default MYSQL_PORTNUM "Port Num:" ${DEFAULT_MYSQL_PORTNUM}
    prompt_with_default MYSQL_DATABASE "Database:" ${DEFAULT_MYSQL_DATABASE}
    prompt_with_default MYSQL_USERNAME "Username:" ${DEFAULT_MYSQL_USERNAME}
    prompt_with_default_password MYSQL_PASSWORD "Password:" ${DEFAULT_MYSQL_PASSWORD}
}

mysql_clear() {
  MYSQL_HOME=""
  mysql=""
}

# Environment:
# - MYSQL_REQUIRED_VERSION (or provide it as a parameter)
mysql_version() {
  local min_version="${1:-${MYSQL_REQUIRED_VERSION}}"
  MYSQL_CLIENT_VERSION=""
  MYSQL_CLIENT_VERSION_OK=""
  if [ -n "$mysql" ]; then
    MYSQL_CLIENT_VERSION=`$mysql --version | sed -e 's/^.*Distrib \([0-9.]*\).*$/\1/g;'`
    if is_version_at_least "$MYSQL_CLIENT_VERSION" "${min_version}"; then
      MYSQL_CLIENT_VERSION_OK=yes
    else
      MYSQL_CLIENT_VERSION_OK=no
    fi
  fi
}

# Environment:
# - MYSQL_REQUIRED_VERSION
mysql_version_report() {
  mysql_version
  if [ "$MYSQL_CLIENT_VERSION_OK" == "yes" ]; then
    echo_success "Mysql client version $MYSQL_CLIENT_VERSION is ok"
  else
    echo_warning "Mysql client version $MYSQL_CLIENT_VERSION is not supported, minimum is ${MYSQL_REQUIRED_VERSION}"
  fi
}

# Environment:
# - MYSQL_REQUIRED_VERSION
mysql_detect() {
  local min_version="${1:-${MYSQL_REQUIRED_VERSION}}"
  if [[ -n "$MYSQL_HOME" && -n "$mysql" && -f "$mysql" ]]; then
    return
  fi
  mysql=`which mysql 2>/dev/null`
  if [ -e "$mysql" ]; then
    MYSQL_HOME=`dirname $mysql`
    echo "Found mysql client: $mysql"
    mysql_version ${min_version}
    if [ "$MYSQL_CLIENT_VERSION_OK" != "yes" ]; then
  MYSQL_HOME=''
  mysql=""
    fi
  fi
}


mysql_server_detect() {
  if [[ -n "$mysqld" && -f "$mysqld" ]]; then
    return 0
  fi
  if [[ -f /sbin/service && -f /etc/init.d/mysqld ]]; then
    mysqld="service mysqld"
    echo "Found mysql server: $mysqld"
    return 0
  fi
  if [[ -f /usr/bin/mysqld_safe ]]; then
    mysqld="/usr/bin/mysqld_safe"
    echo "Found mysql server: $mysqld"
    return 0
  fi
  mysqld=`which mysqld_safe 2>/dev/null`
  if [[ -f "$mysqld" ]]; then
    echo "Found mysql server: $mysqld"
    return 0
  fi
  return 1
}


# must load from config file or call mysql_detect prior to calling this function
mysql_env_report() {
  echo "mysql=$mysql"
}

# Environment:
# - MYSQL_REQUIRED_VERSION
mysql_require() {
  local min_version="${1:-${MYSQL_REQUIRED_VERSION}}"
  if [[ -z "$MYSQL_HOME" || -z "$mysql" || ! -f "$mysql" ]]; then
    mysql_detect ${min_version} > /dev/null
  fi
  if [[ -z "$MYSQL_HOME" || -z "$mysql" || ! -f "$mysql" ]]; then
    echo "Cannot find MySQL client version $min_version or later"
    exit 1
  fi
}



# Environment:
# - MYSQL_REQUIRED_VERSION
mysql_connection() {
  mysql_require
  mysql_connect="$mysql --batch --host=${MYSQL_HOSTNAME:-$DEFAULT_MYSQL_HOSTNAME} --port=${MYSQL_PORTNUM:-$DEFAULT_MYSQL_PORTNUM} --user=${MYSQL_USERNAME:-$DEFAULT_MYSQL_USERNAME} --password=${MYSQL_PASSWORD:-$DEFAULT_MYSQL_PASSWORD}"
}

# Environment:
# - MYSQL_REQUIRED_VERSION
# sets the is_mysql_available variable to "yes" or ""
# sets the is_MYSQL_DATABASE_created variable to "yes" or ""
mysql_test_connection() {
  mysql_connection
  is_mysql_available=""
  local mysql_test_result=`$mysql_connect -e "show databases" 2>/tmp/intel.mysql.err | grep "^${MYSQL_DATABASE}\$" | wc -l`
  if [ $mysql_test_result -gt 0 ]; then
    is_mysql_available="yes"
  fi
  mysql_connection_error=`cat /tmp/intel.mysql.err`
  rm -f /tmp/intel.mysql.err
}

# Environment:
# - MYSQL_REQUIRED_VERSION
mysql_test_connection_report() {
  echo -n "Testing database connection... "
  mysql_test_connection
  if [ -n "$is_mysql_available" ]; then
    echo "OK"
  else
    echo "FAILED"
    echo_failure "${mysql_connection_error}"
  fi
}


# Environment:
# - MYSQL_REQUIRED_VERSION
# installs mysql client programs (not the server)
# we need the mysql client to create or patch the database, but
# the server can be installed anywhere
mysql_install() {
  MYSQL_CLIENT_YUM_PACKAGES="mysql"
  MYSQL_CLIENT_APT_PACKAGES="mysql-client"
  mysql_detect > /dev/null
  if [[ -z "$MYSQL_HOME" || -z "$mysql" ]]; then
    auto_install "MySQL client" "MYSQL_CLIENT" >> $INSTALL_LOG_FILE
    if [[ -z "$MYSQL_HOME" || -z "$mysql" ]]; then
      echo_failure "Unable to auto-install MySQL client" | tee -a $INSTALL_LOG_FILE
      echo "MySQL download URL:" >> $INSTALL_LOG_FILE
      echo "http://www.mysql.com/downloads/" >> $INSTALL_LOG_FILE
    fi
  else
    echo "MySQL client is already installed" >> $INSTALL_LOG_FILE
  fi
}

# Environment:
# - MYSQL_REQUIRED_VERSION
# installs mysql server 
mysql_server_install() {
  MYSQL_SERVER_YUM_PACKAGES="mysql-server"
  MYSQL_SERVER_APT_PACKAGES="mysql-server"
  mysql_server_detect >> $INSTALL_LOG_FILE
  if [[ -n "$mysqld" ]]; then
    echo "MySQL server is already installed" >> $INSTALL_LOG_FILE
    return;
  fi
  if [[ -z "$mysqld" ]]; then
    auto_install "MySQL server" "MYSQL_SERVER"   >> $INSTALL_LOG_FILE
    mysql_server_detect
  fi
  if [[ -z "$mysqld" ]]; then
    MYSQL_SERVER_YUM_PACKAGES=""
    MYSQL_SERVER_APT_PACKAGES="mysql-server-5.5"
    auto_install "MySQL server" "MYSQL_SERVER"  >> $INSTALL_LOG_FILE
    mysql_server_detect
  fi
  if [[ -z "$mysqld" ]]; then
    MYSQL_SERVER_YUM_PACKAGES=""
    MYSQL_SERVER_APT_PACKAGES="mysql-server-5.1"
    auto_install "MySQL server" "MYSQL_SERVER"  >> $INSTALL_LOG_FILE
    mysql_server_detect
  fi
  if [[ -z "$mysqld" ]]; then
    echo_failure "Unable to auto-install MySQL server" | tee -a $INSTALL_LOG_FILE
    echo "MySQL download URL:"  >> $INSTALL_LOG_FILE
    echo "http://www.mysql.com/downloads/" >> $INSTALL_LOG_FILE
  fi
}

# responsible for ensuring that the connection properties in the config file
# Call this from the control script such as "asctl" before calling the other mysql_* functions
# Parameters:
# - absolute path to configuration file
# - prefix of mysql property file names (java style, dot is added automatically)
# Environment:
# - script_name such as 'asctl' or 'wlmctl'
# - intel_conf_dir (deprecated, just use absolute package_config_filename)
# - package_config_filename  (should be absolute)
mysql_configure_connection() {
    local config_file="${1:-/etc/intel/cloudsecurity/mysql.properties}"
    local prefix="${2:-mysql}"
    mysql_test_connection
    if [ -z "$is_mysql_available" ]; then
      mysql_read_connection_properties "${config_file}" "${prefix}"
      mysql_test_connection
    fi
    while [ -n "$mysql_connection_error" ]
    do
      echo_warning "Cannot connect to MySQL: $mysql_connection_error"
      prompt_yes_no MYSQL_RETRY_CONFIGURE_AFTER_FAILURE "Do you want to configure it now?"
      if [[ "no" == "$MYSQL_RETRY_CONFIGURE_AFTER_FAILURE" ]]; then
        echo "MySQL settings are in ${package_config_filename}"
        echo "Run '${script_name} setup' after configuring to continue."
        return 1
      fi
      mysql_userinput_connection_properties
      mysql_test_connection
    done
      echo_success "Connected to database \`${MYSQL_DATABASE}\` on ${MYSQL_HOSTNAME}"
#      local should_save
#      prompt_yes_no should_save "Save in ${package_config_filename}?"
#      if [[ "yes" == "${should_save}" ]]; then
        mysql_write_connection_properties "${config_file}" "${prefix}"
#      fi
}


# requires a mysql connection that can access the existing database, OR (if it doesn't exist)
# requires a mysql connection that can create databases and grant privileges
# call mysql_configure_connection before calling this function
mysql_create_database() {
  mysql_test_connection
  local create_sql="CREATE DATABASE \`${MYSQL_DATABASE}\`;"
  local grant_sql="GRANT ALL ON \`${MYSQL_DATABASE}\`.* TO \`${MYSQL_USERNAME}\` IDENTIFIED BY '${MYSQL_PASSWORD}';"
  if [ -z "$mysql_connection_error" ]; then
    if [ -n "$is_mysql_available" ]; then
      echo_success "Database \`${MYSQL_DATABASE}\` already exists"   >> $INSTALL_LOG_FILE
      return 0
    else
      echo "Creating database..."    >> $INSTALL_LOG_FILE
      $mysql_connect -e "${create_sql}"
      $mysql_connect -e "${grant_sql}"
      mysql_test_connection
      if [ -z "$is_mysql_available" ]; then
        echo_failure "Failed to create database."  | tee -a $INSTALL_LOG_FILE
        return 1
      fi
    fi
  else
    echo_failure "Cannot connect to database."  | tee -a $INSTALL_LOG_FILE
    echo "Try to execute the following commands on the database:"  >> $INSTALL_LOG_FILE
    echo "${create_sql}" >> $INSTALL_LOG_FILE
    echo "${grant_sql}"  >> $INSTALL_LOG_FILE
    return 1
  fi
}

# before using this function, you must first set the connection variables mysql_*
# example:  mysql_run_script /path/to/statements.sql
mysql_run_script() {
  local scriptfile="${1}"
  local datestr=`date +%Y-%m-%d.%H%M`
  echo "##### [${datestr}] Script file: ${scriptfile}" >> ${mysql_setup_log}
  $mysql_connect --force ${MYSQL_DATABASE} < "${scriptfile}" 2>> ${mysql_setup_log}
}

# requires a mysql connection that can create tables and procedures inside an existing database.
# depends on mysql_* variables for the connection information.
# call mysql_configure_connection before calling this function.
# Parameters: a list of sql files to execute (absolute paths)
mysql_install_scripts() {
  local scriptlist="$@"
  mysql_test_connection
  if [ -n "$is_mysql_available" ]; then
    echo "Connected to ${MYSQL_HOSTNAME} as ${MYSQL_USERNAME}. Executing script..."
    for scriptname in $scriptlist
    do
        mysql_run_script $scriptname
    done
    return 0
  else
    echo_failure "Cannot connect to database."
    return 1
  fi
}



mysql_running() {  
  MYSQL_SERVER_RUNNING=''
  if [ -n "$mysqld" ]; then
    local is_running=`$mysqld status | grep running`
    if [ -n "$is_running" ]; then
      MYSQL_SERVER_RUNNING=yes
    fi
  fi
}

mysql_running_report() {
  echo -n "Checking MySQL process... "
  mysql_running
  if [[ "$MYSQL_SERVER_RUNNING" == "yes" ]]; then
    echo "Running"
  else
    echo "Not running"
  fi
}
mysql_start() {
  if [ -n "$mysqld" ]; then
      $mysqld start
  fi
}
mysql_stop() {
  if [ -n "$mysqld" ]; then
      $mysqld stop
  fi
}

mysql_configure_ca() {
  export mysql_ssl_ca_dir="${1:-/etc/intel/cloudsecurity/mysql-ca}"
  # derive CA settings
  export mysql_ssl_ca_key="${mysql_ssl_ca_dir}/ca.key.pem"
  export mysql_ssl_ca_cert="${mysql_ssl_ca_dir}/ca.cert.pem"
  export mysql_ssl_ca_index="${mysql_ssl_ca_dir}/index"  
}

mysql_configure_ssl() {
  export mysql_ssl_dir="${1:-/etc/intel/cloudsecurity/mysql-ssl}"
}

# Parameters:
# - CA directory where private key, public key, and index is kept
mysql_create_ca() {
  mysql_configure_ca "${1:-$mysql_ssl_ca_dir}"
  # create CA
  if [ -f "${mysql_ssl_ca_key}" ]; then
    echo_warning "CA key already exists"
  else
    echo "Creating MySQL Certificate Authority..."
    mkdir -p "${mysql_ssl_ca_dir}"
    chmod 700 "${mysql_ssl_ca_dir}"
    touch "${mysql_ssl_ca_key}"
    chmod 600 "${mysql_ssl_ca_key}"
    openssl genrsa 2048 > "${mysql_ssl_ca_key}"
    openssl req -new -x509 -nodes -days 3650 -key "${mysql_ssl_ca_key}" -out "${mysql_ssl_ca_cert}" -subj "/CN=MySQL SSL CA/OU=Mt Wilson/O=Intel/C=US/"
    echo 0 > "${mysql_ssl_ca_index}"
  fi
}

# Parameters:
# - SSL request file (input)
# - SSL certificate file (output)
# - SSL CA dir
mysql_ca_sign() {
  local ssl_req="${1}"
  local ssl_cert="${2}"
  mysql_configure_ca "${3:-$mysql_ssl_ca_dir}"
  local prev_index next_index
  if [ -f "${mysql_ssl_ca_index}" ]; then
    prev_index=`cat "${mysql_ssl_ca_index}"`
    ((next_index=prev_index + 1))
  else
    echo_failure "Cannot find MySQL CA"
    return 1
  fi
  openssl x509 -req -in "${ssl_req}" -days 3650 -CA "${mysql_ssl_ca_cert}" -CAkey "${mysql_ssl_ca_key}"  -set_serial "${next_index}" -out "${ssl_cert}"
  echo "${next_index}" > "${mysql_ssl_ca_index}"
}

# Parameters:
# - SSL subject name (goes into the common name field in the certificate)
# - SSL directory where you keep server and client SSL keys and certificates
# - SSL CA directory
# Environment:
# you must have already created the CA key. the CA key information
# should be in the environment variables:
# MTWILSON_CA_KEY=/path/to/file
# MTWILSON_CA_CERT=/path/to/file
# MTWILSON_CA_PASSWORD=password
mysql_create_ssl() {
  local dname="${1}"
  mysql_configure_ssl "${2:-$mysql_ssl_dir}"
  mysql_configure_ca "${3:-$mysql_ssl_ca_dir}"
  echo "Creating MySQL SSL Certificate..."
  mkdir -p "${mysql_ssl_dir}"
  if [ -z "$dname" ]; then
    prompt_with_default MYSQL_SSL_CERT_CN "Common name (username):"
    dname=${MYSQL_SSL_CERT_CN}
  fi
  local filename=`echo "${dname}" | sed "s/[^a-zA-Z0-9-]/_/g"`
  local ssl_key="${mysql_ssl_dir}/${filename}.key.pem"
  local ssl_cert="${mysql_ssl_dir}/${filename}.cert.pem"
  openssl req -newkey rsa:1024 -days 3650 -nodes -keyout "${ssl_key}" -out "${ssl_cert}.req" -subj "/CN=${dname}/OU=Mt Wilson/O=Intel/C=US/"
  openssl rsa -in "${ssl_key}" -out "${ssl_key}"
  mysql_ca_sign "${ssl_cert}.req" "${ssl_cert}" "${mysql_ssl_ca_dir}"
  rm -rf "${ssl_cert}.req"
  # verify the certificate
  echo "Verifying SSL Certificate..."
  openssl verify -CAfile "${mysql_ssl_ca_cert}" "${ssl_cert}"
}

### FUNCTION LIBRARY: postgres


postgres_clear() {
  POSTGRES_HOME=""
  psql=""
}

# Environment:
# - POSTGRES_REQUIRED_VERSION
postgres_version_report() {
  postgres_version
  if [ "$POSTGRES_CLIENT_VERSION_OK" == "yes" ]; then
    echo_success "Postgres client version $POSTGRES_CLIENT_VERSION is ok"
  else
    echo_warning "Postgres client version $POSTGRES_CLIENT_VERSION is not supported, minimum is ${POSTGRES_REQUIRED_VERSION}"
  fi
}

# Environment:
# - POSTGRES_REQUIRED_VERSION
# installs postgres client programs (not the server)
# we need the postgres client to create or patch the database, but
# the server can be installed anywhere
postgres_install() {
  POSTGRES_CLIENT_YUM_PACKAGES="postgresql-client-common"
  POSTGRES_CLIENT_APT_PACKAGES="postgresql-client-common"
  postgres_detect >> $INSTALL_LOG_FILE

  if [[ -z "$POSTGRES_HOME" || -z "$psql" ]]; then
    auto_install "Postgres client" "POSTGRES_CLIENT" >> $INSTALL_LOG_FILE
    if [[ -z "$POSTGRES_HOME" || -z "$psql" ]]; then
      echo_failure "Unable to auto-install Postgres client" | tee -a $INSTALL_LOG_FILE
      echo "Postgres download URL:" >> $INSTALL_LOG_FILE
      echo "http://www.postgresql.org/download/" >> $INSTALL_LOG_FILE
    fi
  else
    echo "Postgres client is already installed" >> $INSTALL_LOG_FILE
    echo "Postgres client is already installed skipping..."
  fi
}

# Environment:
# - POSTGRES_REQUIRED_VERSION
# installs postgres server 
postgres_server_install(){
  POSTGRES_SERVER_YUM_PACKAGES="postgresql"
  POSTGRES_SERVER_APT_PACKAGES="postgresql"

  postgres_server_detect >> $INSTALL_LOG_FILE
  if [[ -n "$postgresd" ]]; then
    echo "Postgres server is already installed" >> $INSTALL_LOG_FILE
    echo "Postgres server is already installed skipping..."
    return;
  fi
  if [[ -z "$postgresd" ]]; then
    auto_install "Postgres server" "POSTGRES_SERVER"   >> $INSTALL_LOG_FILE
    postgres_server_detect
  fi
  
  if [[ -z "$postgresd" ]]; then
    echo_failure "Unable to auto-install Postgres server" | tee -a $INSTALL_LOG_FILE
    echo "Postgres download URL:"  >> $INSTALL_LOG_FILE
    echo "http://www.postgresql.org/download/" >> $INSTALL_LOG_FILE
    return 1
  fi

  #if we get here postgres was a fresh install. Need to create the account entered by user
  local create_user_sql="CREATE USER ${POSTGRES_USERNAME:-$DEFAULT_POSTGRES_USERNAME} WITH PASSWORD '${POSTGRES_PASSWORD:-$DEFAULT_POSTGRES_PASSWORD}';"
  sudo -u postgres psql postgres -c "${create_user_sql}" 2>/tmp/intel.postgres.err    >> $INSTALL_LOG_FILE
  echo host  all  all  $MTWILSON_SERVER_IP_ADDRESS/32	password >> $postgresh
  echo listen_addresses = \'*\' >> $postgresc

}

# Environment:
# - POSTGRES_REQUIRED_VERSION
postgres_detect(){
  local min_version="${1:-${POSTGRES_REQUIRED_VERSION}}"
  if [[ -n "$POSTGRES_HOME" && -n "$psql" && -f "$psql" ]]; then
    echo "postgres detected. returning..."
    return
  fi
  psql=`which psql 2>/dev/null`
  export psql
  echo "psql=$psql"
  
  if [ -e "$psql" ]; then
    POSTGRES_HOME=`dirname $psql`
    echo "Found postgres client: $psql"
    postgres_version ${min_version}
    if [ "$POSTGRES_CLIENT_VERSION_OK" != "yes" ]; then
      echo "postgres client version not ok. resetting psql=''"
      POSTGRES_HOME=''
      psql=""
    fi
  fi
echo "POSTGRES_CLIENT_VERSION_OK: $POSTGRES_CLIENT_VERSION_OK"
}

postgres_server_detect() {
  #find the host file
  postgresh=`find / -name pg_hba.conf`
  #find the configuration file
  postgresc=`find / -name postgresql.conf`

  echo "postgresh=$postgresh"

  if [[ -n "$postgresd" && -f "$postgresd" ]]; then
    echo "Found postgres server: $postgresd"
    return 0
  fi
  if [[ -n /usr/share/postgresql && -f /etc/init.d/postgresql ]]; then
    postgresd="/etc/init.d/postgresql"
    echo "Found postgres server: $postgresd"
    return 0
  fi
  echo "Postgres server not found"
  return 1
}
postgres_version(){
  local min_version="${1:-${POSTGRES_REQUIRED_VERSION}}"
  POSTGRES_CLIENT_VERSION=""
  POSTGRES_CLIENT_VERSION_OK=""

  if [ -n "$psql" ]; then
    POSTGRES_CLIENT_VERSION=`$psql --version |  head -n1 | awk '{print $3}'`
    echo "POSTGRES_CLIENT_VERSION: $POSTGRES_CLIENT_VERSION"
    if is_version_at_least "$POSTGRES_CLIENT_VERSION" "${min_version}"; then
      POSTGRES_CLIENT_VERSION_OK=yes
    else
      POSTGRES_CLIENT_VERSION_OK=no
    fi
  fi
  echo "POSTGRES_CLIENT_VERSION_OK: $POSTGRES_CLIENT_VERSION_OK"
}

# must load from config file or call postgres_detect prior to calling this function
postgres_env_report() {
  echo "psql=$psql"
}

# Environment:
# - POSTGRES_REQUIRED_VERSION
postgres_require() {
  local min_version="${1:-${POSTGRES_REQUIRED_VERSION}}"
  if [[ -z "$POSTGRES_HOME" || -z "$psql" || ! -f "$psql" ]]; then
    postgres_detect ${min_version} > /dev/null
  fi
  if [[ -z "$POSTGRES_HOME" || -z "$psql" || ! -f "$psql" ]]; then
    echo "Cannot find Postgres client version $min_version or later"
    #exit 1
  fi
}


# Environment:
# - POSTGRES_REQUIRED_VERSION\
# format like this -> psql -h 127.0.0.1 -p 5432 -d mw_as -U root -c "\l"
postgres_connection() {
  postgres_require
  postgres_connect="psql -h ${POSTGRES_HOSTNAME:-$DEFAULT_POSTGRES_HOSTNAME} -p ${POSTGRES_PORTNUM:-$DEFAULT_POSTGRES_PORTNUM} -d ${POSTGRES_DATABASE:-$DEFAULT_POSTGRES_DATABASE} -U ${POSTGRES_USERNAME:-$DEFAULT_POSTGRES_USERNAME}"
  echo $postgres_connect
}

# Environment:
# - POSTGRES_REQUIRED_VERSION
# sets the is_postgres_available variable to "yes" or ""
postgres_test_connection() {
  postgres_connection
  is_postgres_available=""
  #check if postgres is installed and we can connect with provided credencials
  local postgres_test_result=`$postgres_connect -c '\l' 2>/tmp/intel.postgres.err | grep ${POSTGRES_DATABASE:-$DEFAULT_POSTGRES_DATABASE} | wc -l`
  if [ $postgres_test_result -gt 0 ]; then
    is_postgres_available="yes"
  fi
  postgres_connection_error=`cat /tmp/intel.postgres.err`
  
  #echo "postgres_connection_error: $postgres_connection_error"
  rm -f /tmp/intel.postgres.err
}

# Environment:
# - POSTGRES_REQUIRED_VERSION
postgres_test_connection_report() {
  echo -n "Testing database connection... "
  postgres_test_connection
  if [ -n "$is_postgres_available" ]; then
    echo "OK"
  else
    echo "FAILED"
    echo_failure "${postgres_connection_error}"
  fi
}

# responsible for ensuring that the connection properties in the config file
# Call this from the control script such as "asctl" before calling the other postgres_* functions
# Parameters:
# - absolute path to configuration file
# - prefix of psql property file names (java style, dot is added automatically)
# Environment:
# - script_name such as 'asctl' or 'wlmctl'
# - intel_conf_dir (deprecated, just use absolute package_config_filename)
# - package_config_filename  (should be absolute)
postgres_configure_connection() {
    local config_file="${1:-/etc/intel/cloudsecurity/postgres.properties}"
    local prefix="${2:-postgres}"
    postgres_test_connection
    if [ -z "$is_postgres_available" ]; then
      postgres_read_connection_properties "${config_file}" "${prefix}"
      postgres_test_connection
    fi
    while [ -n "$postgres_connection_error" ]
    do
      echo_warning "Cannot connect to Postgres: $postgres_connection_error"
      prompt_yes_no POSTGRES_RETRY_CONFIGURE_AFTER_FAILURE "Do you want to configure it now?"
      if [[ "no" == "$POSTGRES_RETRY_CONFIGURE_AFTER_FAILURE" ]]; then
        echo "Postgres settings are in ${package_config_filename}"
        echo "Run '${script_name} setup' after configuring to continue."
        return 1
      fi
      postgres_userinput_connection_properties
      postgres_test_connection
    done
      echo_success "Connected to database \`${POSTGRES_DATABASE}\` on ${POSTGRES_HOSTNAME}"
#      local should_save
#      prompt_yes_no should_save "Save in ${package_config_filename}?"
#      if [[ "yes" == "${should_save}" ]]; then
        postgres_write_connection_properties "${config_file}" "${prefix}"
#      fi
}


# requires a postgres connection that can access the existing database, OR (if it doesn't exist)
# requires a postgres connection that can create databases and grant privileges
# call postgres_configure_connection before calling this function
postgres_create_database() {
  postgres_test_connection

  local create_sql="CREATE DATABASE ${POSTGRES_DATABASE:-$DEFAULT_POSTGRES_DATABASE};"
  local grant_sql="GRANT ALL PRIVILEGES ON DATABASE ${POSTGRES_DATABASE:-$DEFAULT_POSTGRES_DATABASE} TO ${POSTGRES_USERNAME:-$DEFAULT_POSTGRES_USERNAME};"

  if [ -n "$is_postgres_available" ]; then
    echo_success "Database \`${POSTGRES_DATABASE}\` already exists"
    echo_success "Database \`${POSTGRES_DATABASE}\` already exists"   >> $INSTALL_LOG_FILE
    return 0
  else
    echo "Creating database..."    >> $INSTALL_LOG_FILE
    sudo -u postgres psql postgres -c "${create_sql}" 2>/tmp/intel.postgres.err    >> $INSTALL_LOG_FILE
    postgres_connection_error=`cat /tmp/intel.postgres.err`
    echo "postgres_connection_error: $postgres_connection_error"
    sudo -u postgres psql postgres -c "${grant_sql}" 2>/tmp/intel.postgres.err    >> $INSTALL_LOG_FILE
    postgres_connection_error=`cat /tmp/intel.postgres.err`
    echo "postgres_connection_error: $postgres_connection_error"

    postgres_test_connection
    if [ -z "$is_postgres_available" ]; then
      echo_failure "Failed to create database."  | tee -a $INSTALL_LOG_FILE
      echo "Try to execute the following commands on the database:"  >> $INSTALL_LOG_FILE
      echo "${create_sql}" >> $INSTALL_LOG_FILE
      echo "${grant_sql}"  >> $INSTALL_LOG_FILE
      return 1
    fi
  fi
}

# before using this function, you must first set the connection variables postgres_*
# example:  postgres_run_script /path/to/statements.sql
postgres_run_script() {
  local scriptfile="${1}"
  local datestr=`date +%Y-%m-%d.%H%M`
  echo "##### [${datestr}] Script file: ${scriptfile}" >> ${postgres_setup_log}
  $postgres_connect --force ${POSTGRES_DATABASE} < "${scriptfile}" 2>> ${postgres_setup_log}
}

# requires a postgres connection that can create tables and procedures inside an existing database.
# depends on postgres_* variables for the connection information.
# call postgres_configure_connection before calling this function.
# Parameters: a list of sql files to execute (absolute paths)
postgres_install_scripts() {
  local scriptlist="$@"
  postgresd_test_connection
  if [ -n "$is_postgres_available" ]; then
    echo "Connected to ${POSTGRES_HOSTNAME} as ${POSTGRES_USERNAME}. Executing script..."
    for scriptname in $scriptlist
    do
        postgres_run_script $scriptname
    done
    return 0
  else
    echo_failure "Cannot connect to database."
    return 1
  fi
}

postgres_running() {  
  POSTGRES_SERVER_RUNNING=''
  if [ -n "$postgresd" ]; then
    local is_running=`$postgresd status | grep running`
    if [ -n "$is_running" ]; then
      POSTGRES_SERVER_RUNNING=yes
    fi
  fi
}

postgres_running_report() {
  echo -n "Checking Postgres process... "
  postgres_running
  if [[ "$POSTGRES_SERVER_RUNNING" == "yes" ]]; then
    echo "Running"
  else
    echo "Not running"
  fi
}
postgres_restart() {
  if [ -n "$postgresd" ]; then
      $postgresd restart
  fi
}
postgres_start() {
  if [ -n "$postgresd" ]; then
      $postgresd start
  fi
}
postgres_stop() {
  if [ -n "$postgresd" ]; then
      $postgresd stop
  fi
}

postgres_configure_ca() {
  export postgres_ssl_ca_dir="${1:-/etc/intel/cloudsecurity/postgres-ca}"
  # derive CA settings
  export postgres_ssl_ca_key="${postgres_ssl_ca_dir}/ca.key.pem"
  export postgres_ssl_ca_cert="${postgres_ssl_ca_dir}/ca.cert.pem"
  export postgres_ssl_ca_index="${postgres_ssl_ca_dir}/index"  
}

postgres_configure_ssl() {
  export postgres_ssl_dir="${1:-/etc/intel/cloudsecurity/postgres-ssl}"
}

# Parameters:
# - CA directory where private key, public key, and index is kept
postgres_create_ca() {
  postgres_configure_ca "${1:-$postgres_ssl_ca_dir}"
  # create CA
  if [ -f "${postgres_ssl_ca_key}" ]; then
    echo_warning "CA key already exists"
  else
    echo "Creating Postgres Certificate Authority..."
    mkdir -p "${postgres_ssl_ca_dir}"
    chmod 700 "${postgres_ssl_ca_dir}"
    touch "${postgres_ssl_ca_key}"
    chmod 600 "${postgres_ssl_ca_key}"
    openssl genrsa 2048 > "${postgres_ssl_ca_key}"
    openssl req -new -x509 -nodes -days 3650 -key "${postgres_ssl_ca_key}" -out "${postgres_ssl_ca_cert}" -subj "/CN=Posgres SSL CA/OU=Mt Wilson/O=Intel/C=US/"
    echo 0 > "${postgres_ssl_ca_index}"
  fi
}

# Parameters:
# - SSL request file (input)
# - SSL certificate file (output)
# - SSL CA dir
postgres_ca_sign() {
  local ssl_req="${1}"
  local ssl_cert="${2}"
  postgres_configure_ca "${3:-$postgres_ssl_ca_dir}"
  local prev_index next_index
  if [ -f "${postgres_ssl_ca_index}" ]; then
    prev_index=`cat "${postgres_ssl_ca_index}"`
    ((next_index=prev_index + 1))
  else
    echo_failure "Cannot find Postgres CA"
    return 1
  fi
  openssl x509 -req -in "${ssl_req}" -days 3650 -CA "${postgres_ssl_ca_cert}" -CAkey "${postgres_ssl_ca_key}"  -set_serial "${next_index}" -out "${ssl_cert}"
  echo "${next_index}" > "${postgres_ssl_ca_index}"
}

# Parameters:
# - SSL subject name (goes into the common name field in the certificate)
# - SSL directory where you keep server and client SSL keys and certificates
# - SSL CA directory
# Environment:
# you must have already created the CA key. the CA key information
# should be in the environment variables:
# MTWILSON_CA_KEY=/path/to/file
# MTWILSON_CA_CERT=/path/to/file
# MTWILSON_CA_PASSWORD=password
postgres_create_ssl() {
  local dname="${1}"
  postgres_configure_ssl "${2:-$postgres_ssl_dir}"
  postgres_configure_ca "${3:-$postgres_ssl_ca_dir}"
  echo "Creating Postgres SSL Certificate..."
  mkdir -p "${postgres_ssl_dir}"
  if [ -z "$dname" ]; then
    prompt_with_default POSTGRES_SSL_CERT_CN "Common name (username):"
    dname=${POSTGRES_SSL_CERT_CN}
  fi
  local filename=`echo "${dname}" | sed "s/[^a-zA-Z0-9-]/_/g"`
  local ssl_key="${postgres_ssl_dir}/${filename}.key.pem"
  local ssl_cert="${postgres_ssl_dir}/${filename}.cert.pem"
  openssl req -newkey rsa:1024 -days 3650 -nodes -keyout "${ssl_key}" -out "${ssl_cert}.req" -subj "/CN=${dname}/OU=Mt Wilson/O=Intel/C=US/"
  openssl rsa -in "${ssl_key}" -out "${ssl_key}"
  postgres_ca_sign "${ssl_cert}.req" "${ssl_cert}" "${postgres_ssl_ca_dir}"
  rm -rf "${ssl_cert}.req"
  # verify the certificate
  echo "Verifying SSL Certificate..."
  openssl verify -CAfile "${postgres_ssl_ca_cert}" "${ssl_cert}"
}


### FUNCTION LIBRARY: glassfish

glassfish_clear() {
  GLASSFISH_HOME=""
  glassfish_bin=""
  glassfish=""
}

glassfish_ready_report() {
  if [[ -z "$GLASSFISH_HOME" ]]; then echo_warning "GLASSFISH_HOME variable is not set"; return 1; fi
  if [[ -z "$glassfish_bin" ]]; then echo_warning "Glassfish binary path is not set"; return 1; fi
  if [[ ! -f "$glassfish_bin" ]]; then echo_warning "Cannot find Glassfish binary at $glassfish_bin"; return 1; fi
  if [[ -z "$glassfish" ]]; then echo_warning "Glassfish command is not set"; return 1; fi
  echo_success "Using Glassfish at $GLASSFISH_HOME"
  return 0
}


glassfish_ready() {
  glassfish_ready_report > /dev/null
  return $?
}

# How to use;   GLASSFISH_VERSION=`glassfish_version`
# If you pass a parameter, it is the path to a glassfish "asadmin" binary 
# If you do not pass a parameter, the "glassfish" variable is used as the path to the binary
glassfish_version() {
  if [[ -n "$glassfish" ]]; then
    # extract the version number from a string like: glassfish version "3.0"
    local current_glassfish_version=`$glassfish version 2>&1 | grep -i glassfish | grep -i version | awk '{ print $8 }'`
    if [ -n "$current_glassfish_version" ]; then
      echo $current_glassfish_version
      return 0
    fi
    return 2
  fi
  return 1
}

# Environment:
# - glassfish_required_version
glassfish_version_report() {
  local min_version="${1:-${GLASSFISH_REQUIRED_VERSION:-$DEFAULT_GLASSFISH_REQUIRED_VERSION}}"
  GLASSFISH_VERSION=`glassfish_version`
  if is_version_at_least "$GLASSFISH_VERSION" "${min_version}"; then
    echo_success "Glassfish version $GLASSFISH_VERSION is ok"
    return 0
  else
    echo_warning "Glassfish version $GLASSFISH_VERSION is not supported, minimum is ${min_version}"
    return 1
  fi
}

# detects possible glassfish installations
# does nothing if GLASSFISH_HOME is already set; unset with glassfish_clear before calling to force detection
# Environment:
# - GLASSFISH_REQUIRED_VERSION (or provide it as a parameter)
# Parameters:
# - minimum required version
glassfish_detect() {
  local min_version="${1:-${GLASSFISH_REQUIRED_VERSION:-${DEFAULT_GLASSFISH_REQUIRED_VERSION}}}"

      if [[ -n "$java" ]]; then    
        local java_bindir=`dirname $java`
      fi
  # start with GLASSFISH_HOME if it is already configured
  if [[ -n "$GLASSFISH_HOME" ]]; then
    if [[ -z "$glassfish_bin" ]]; then
      glassfish_bin="$GLASSFISH_HOME/bin/asadmin"
    fi
    if [[ -z "$glassfish" ]]; then
      if [[ -n "$java" ]]; then    
        # the glassfish admin tool read timeout is in milliseconds, so 900,000 is 900 seconds
        glassfish="env PATH=$java_bindir:$PATH AS_ADMIN_READTIMEOUT=900000 $glassfish_bin"
      else
        glassfish="env AS_ADMIN_READTIMEOUT=900000 $glassfish_bin"
      fi
    fi
    if [[ -n "$glassfish" ]]; then
      GLASSFISH_VERSION=`glassfish_version`
      if is_version_at_least "$GLASSFISH_VERSION" "${min_version}"; then
        return 0
      fi
    fi
  fi

  GLASSFISH_CANDIDATES=`find / -name domains 2>/dev/null | grep glassfish/domains`
#  echo "Candidates: $GLASSFISH_CANDIDATES"
  for c in $GLASSFISH_CANDIDATES
  do
      local parent=`dirname $c`
 #     echo "Checking Glassfish: $parent"
      if [ -f "$parent/bin/asadmin" ]; then
        GLASSFISH_HOME="$parent"
        glassfish_bin="$GLASSFISH_HOME/bin/asadmin"
        # the glassfish admin tool read timeout is in milliseconds, so 900,000 is 900 seconds
        glassfish="env PATH=$java_bindir:$PATH AS_ADMIN_READTIMEOUT=900000 $glassfish_bin"
        echo "Found Glassfish: $GLASSFISH_HOME"
#        echo "Found Glassfish: $glassfish"
        GLASSFISH_VERSION=`glassfish_version`
        if is_version_at_least "$GLASSFISH_VERSION" "${min_version}"; then
          return 0
        fi
      fi
  done
  echo_failure "Cannot find Glassfish"
  glassfish_clear
  return 1
  # read the admin username and pasword, if present. format of both files is shell  VARIABLE=VALUE
#  if [ -f /etc/glassfish/admin.user ]; then
#    export AS_ADMIN_USER=`read_property_from_file AS_ADMIN_USER /etc/glassfish/admin.user`
#  fi
#  if [ -f /etc/glassfish/admin.passwd ]; then
#    export AS_ADMIN_PASSWORDFILE=/etc/glassfish/admin.passwd
#  fi
}

# must load from config file or call glassfish_detect prior to calling this function
glassfish_env_report() {
  echo "GLASSFISH_HOME=$GLASSFISH_HOME"
  echo "glassfish_bin=$glassfish_bin"
  echo "glassfish=\"$glassfish\""
}


# Environment:
# - glassfish_required_version (or provide it as a parameter)
glassfish_require() {
  local min_version="${1:-${GLASSFISH_REQUIRED_VERSION:-${DEFAULT_GLASSFISH_REQUIRED_VERSION}}}"
  if not glassfish_ready; then
    glassfish_detect ${min_version} > /dev/null
  fi
  if not glassfish_ready; then
    echo_failure "Cannot find Glassfish server version $min_version or later"
    exit 1
  fi
}

# usage:  if no_glassfish 3.0; then echo_failure "Cannot find Glassfish"; exit 1; fi
no_glassfish() {
  if glassfish_require $1; then return 1; else return 0; fi
}

# Run this AFTER glassfish_install
# optional global variables:  
#   glassfish_username (default value glassfish)
#   GLASSFISH_HOME (default value /usr/share/glassfish3)
# works on Debian, Ubuntu, CentOS, RedHat, SUSE
# Username should not contain any spaces or punctuation
# Optional arguments:  one or more directories for glassfish user to own
glassfish_permissions() {
  local chown_locations="$@"
  local username=${glassfish_username:-glassfish}
  local user_exists=`cat /etc/passwd | grep "^${username}"`
  if [ -z "$user_exists" ]; then
    useradd -c "Glassfish" -d "${GLASSFISH_HOME:-/usr/share/glassfish3}" -r -s /bin/bash "$username"
  fi
  local file
  for file in $chown_locations
  do
    if [[ -n "$file" && -e "$file" ]]; then
      chown -R "${username}:${username}" "$file"
    fi
  done
}

# sets a system property for logback configuration file location
# requires a running glassfish
glassfish_logback() {
  # see if it's already set
  local prev_logback=`$glassfish list-system-properties 2>/dev/null | grep "logback.configurationFile"| head -n 1`
  # loop just in case there is more than one defined
#  while [ -n "${prev_logback}" ]
#  do
    echo "Deleting existing system property ${prev_logback}"
    $glassfish delete-system-property "${prev_logback}" 2>/dev/null >/dev/null
#    prev_logback=`$glassfish list-system-properties 2>/dev/null | grep "logback.configurationFile" | head -n 1`
#  done
  $glassfish create-system-properties logback.configurationFile=/etc/intel/cloudsecurity/logback.xml
}

# set the -Xmx and -XX:MaxPermSize memory parameters for the glassfish JVM
glassfish_memory() {
  local jvm_memory="${1:-2048}"
  local jvm_maxperm="${2:-512}"
  # glassfish must be started in order to do this
  
  # first we have to find the current options and remove them
  local prev_jvm_memory=`$glassfish list-jvm-options | grep "\-Xmx" | head -n 1`
  local prev_jvm_maxperm=`$glassfish list-jvm-options | grep "\-XX:MaxPermSize" | head -n 1`
  # loop just in case there is more than one defined
  while [ -n "${prev_jvm_memory}" ]
  do
    echo "Deleting existing option ${prev_jvm_memory}"
    $glassfish delete-jvm-options "${prev_jvm_memory}"
    prev_jvm_memory=`$glassfish list-jvm-options | grep "\-Xmx" | head -n 1`
  done
  # loop just in case there is more than one defined
  while [ -n "${prev_jvm_maxperm}" ]
  do
    # must escape the colon between XX and MaxPermSize
    prev_jvm_maxperm=`echo ${prev_jvm_maxperm} | sed -re "s/:/\\\\\\\\:/"`
    echo "Deleting existing option ${prev_jvm_maxperm}"
    $glassfish delete-jvm-options "${prev_jvm_maxperm}"
    prev_jvm_maxperm=`$glassfish list-jvm-options | grep "\-XX:MaxPermSize" | head -n 1`
  done
  $glassfish create-jvm-options "-Xmx${jvm_memory}m:-XX\\:MaxPermSize=${jvm_maxperm}m"
}

# reset glassfish overall logging handler to turn on logging
# this is required because glassfish 3.1.1 and later...
#  UI has a bug that causes the
# logging handler to be set to OFF whenever a user saves any change to
# other logging levels. 
# references:
# http://java.net/jira/browse/GLASSFISH-17037
# http://stackoverflow.com/questions/9373629/glassfish-3-1-1-suddenly-stopped-writing-to-server-log
glassfish_enable_logging() {
  $glassfish set-log-levels com.sun.enterprise.server.logging.GFFileHandler=ALL
}

# must restart glassfish for enable-secure-admin and memory options to take effect, so call these after calling this function:
#  glassfish_stop
#  glassfish_start
# (they are not done automatically in case the caller has other glassfish setup that would also require a restart)
# Environment:
# - glassfish_required_version
glassfish_install() {
  local GLASSFISH_PACKAGE="${1:-glassfish.zip}"
  GLASSFISH_YUM_PACKAGES="unzip"
  GLASSFISH_APT_PACKAGES="unzip"
  GLASSFISH_YAST_PACKAGES="unzip"
  GLASSFISH_ZYPPER_PACKAGES="unzip"
  glassfish_detect

  if glassfish_running; then glassfish_stop; fi

  if [[ -z "$GLASSFISH_HOME" || -z "$glassfish" ]]; then
    if [ -d /usr/share/glassfish3 ]; then
      # we do not remove it automatically in case there are applications or data in there that the user wants to save!!
      echo_warning "Glassfish not detected but /usr/share/glassfish3 exists"
      echo "Remove /usr/share/glassfish3 and try again"
      return 1
    fi
    if [[ -z "$GLASSFISH_PACKAGE" || ! -f "$GLASSFISH_PACKAGE" ]]; then
      echo_failure "Missing Glassfish installer: $GLASSFISH_PACKAGE"
      return 1
    fi
    auto_install "Glassfish requirements" "GLASSFISH"
    echo "Installing $GLASSFISH_PACKAGE"
    unzip $GLASSFISH_PACKAGE 2>&1  >/dev/null
    mv glassfish3 /usr/share/
    # Glassfish requires hostname to be mapped to 127.0.0.1 in /etc/hosts
    if [ -f "/etc/hosts" ]; then
        local hostname=`hostname`
        local found=`cat "/etc/hosts" | grep "^127.0.0.1" | grep "$hostname"`
        if [ -z "$found" ]; then
          local datestr=`date +%Y-%m-%d.%H%M`
          cp /etc/hosts /etc/hosts.${datestr}
          local updated=`sed -re "s/^(127.0.0.1\s.*)$/\1 ${hostname}/" /etc/hosts`
          echo "$updated" > /etc/hosts
        fi
    fi
    glassfish_detect
    if [[ -z "$GLASSFISH_HOME" || -z "$glassfish" ]]; then
      echo_failure "Unable to auto-install Glassfish"
      echo "Glassfish download URL:"
      echo "http://glassfish.java.net/"
      return 1
    fi
  else
    echo "Glassfish is already installed in $GLASSFISH_HOME"
  fi

  # TODO this functionality is moving to the java tool ; completely remove it from here
  if [ -n "${MTWILSON_SERVER}" ]; then
    glassfish_create_ssl_cert "${MTWILSON_SERVER}"
  else
    glassfish_create_ssl_cert_prompt
  fi

  glassfish_permissions "${GLASSFISH_HOME}"
  glassfish_start
  #glassfish_admin_user
  glassfish_memory 2048 512
  glassfish_logback
}

# glassfish must already be running to execute "enable-secure-domain",  so glassfish_start is required before calling this function
glassfish_admin_user() {  
  echo "You must choose an administrator username and password for Glassfish"
  echo "The Glassfish control panel is at https://${MTWILSON_SERVER:-127.0.0.1}:4848"
  prompt_with_default AS_ADMIN_USER "Glassfish admin username:"
  export AS_ADMIN_USER
  prompt_with_default_password AS_ADMIN_PASSWORD "Glassfish admin password:"

  export AS_ADMIN_PASSWORDFILE=/etc/glassfish/admin.passwd
  mkdir -p /etc/glassfish
  touch /etc/glassfish/admin.user /etc/glassfish/admin.passwd /etc/glassfish/admin.passwd.old
  chmod 600 /etc/glassfish/admin.user /etc/glassfish/admin.passwd /etc/glassfish/admin.passwd.old
  echo "AS_ADMIN_USER=${AS_ADMIN_USER}" > /etc/glassfish/admin.user
  echo "AS_ADMIN_PASSWORD=${AS_ADMIN_PASSWORD}" > /etc/glassfish/admin.passwd
  echo "AS_ADMIN_PASSWORD=" > /etc/glassfish/admin.passwd.old
  #echo "AS_ADMIN_MASTERPASSWORD=changeit" >> /etc/glassfish/admin.passwd

  echo "Glassfish will now ask you for the same information:"
  # $glassfish is an alias for full path of asadmin
  $glassfish --user=admin --passwordfile=/etc/glassfish/admin.passwd.old change-admin-password
  # XXX it asks for the password twice ...  can we script with our known value?
  $glassfish --user=admin --passwordfile=/etc/glassfish/admin.passwd enable-secure-admin

}

# pre-conditions:   GLASSFISH_HOME  must be set  (find it with glassfish_detect)
# returns success (0) if glassfish is running, error (1) if it is not running
# in order to prevent repetitive calls it also sets the GLASSFISH_RUNNING variable.
# if glassfish is running, it also sets the $GLASSFISH_PID variable to the process id.
# so you can write  if glassfish_running; echo "ok"; fi
# and after that also   if [ "$GLASSFISH_RUNNING" == "yes" ]; then echo "ok"; fi
glassfish_running() {  
  GLASSFISH_RUNNING=''
  if [ -n "$GLASSFISH_HOME" ]; then
    GLASSFISH_PID=`ps gauwxx | grep java | grep -v grep | grep "$GLASSFISH_HOME" | awk '{ print $2 }'`
    if [ -n "$GLASSFISH_PID" ]; then
      GLASSFISH_RUNNING=yes
      return 0
    fi
  fi
  return 1
}

glassfish_running_report() {
  echo -n "Checking Glassfish process... "
  if glassfish_running; then
    echo "Running (pid $GLASSFISH_PID)"
  else
    echo "Not running"
  fi
}
glassfish_start() {
  if [ -n "$glassfish" ]; then
      $glassfish start-domain
  fi
}
glassfish_stop() {
  if [ -n "$glassfish" ]; then
      $glassfish stop-domain
  fi
}
glassfish_restart() {
  if [ -n "$glassfish" ]; then
      $glassfish restart-domain
  fi
}
glassfish_shutdown() {
  glassfish_running
  if [ -n "$GLASSFISH_PID" ]; then
      kill -9 $GLASSFISH_PID
  fi
}
glassfish_start_report() {
  action_condition GLASSFISH_RUNNING "Starting Glassfish" "glassfish_start > /dev/null; glassfish_running;"
}

# Must call java_require before calling this.
# Parameters:
# - certificate alias to report on (default is s1as, the glassfish default ssl cert alias)
glassfish_sslcert_report() {
  local alias="${1:-s1as}"
  local keystorePassword=changeit
  local domain_found=`$glassfish list-domains | head -n 1 | awk '{ print $1 }'`
  local keystore=${GLASSFISH_HOME}/domains/${domain_found}/config/keystore.jks
  java_keystore_cert_report "$keystore" "$keystorePassword" "$alias"
}

# used by attestation_service_install to create a new domain just for attestation service
# parameters:  domain name, domain dir (absolute path)
# example: glassfish_create_domain "intel-as" "${ATTESTATION_SERVICE_HOME}/glassfish/domain"
# TODO ??? if attestation-service is configured to be deployed into a specific domain instead of
# the default domain, then we should define glassfish commands that abstract it so that
# the attestatioN_service_start/stop  don't need to really know that. 
# TODO !!! the create-domain command outputs the following lines which we need to capture so
# we can know the URL's for the new domain:
#
#Default port 4848 for Admin is in use. Using 39766
#Default port 8080 for HTTP Instance is in use. Using 41112
#Default port 7676 for JMS is in use. Using 52108
#Default port 3700 for IIOP is in use. Using 46322
#Default port 8181 for HTTP_SSL is in use. Using 42364
#
glassfish_create_domain() {
  local domain_name=${1}
  local domain_dir=${2}
  if [ -n "$glassfish" ]; then
    $glassfish create-domain --domaindir "${domain_dir}" "${domain_name}"
    $glassfish start-domain --domaindir "${domain_dir}" "${domain_name}"
  fi
}

# ??? see comment below about deleting the domain dir.  MAYBE the answer is
# to not provide a domain deletion command at all???? just create the domain if
# it does not exist and if it does install into it and we never delete the domain
# or its log files. OR, on uninstall we can delete the domain but just let the
# log files stay and sysadmin will have to clean that up if he wants to reinstall???
# or better to just undeploy the app on uninstall and leave the domain alone. 
glassfish_delete_domain() {
  local domain_name=${1}
  local domain_dir=${2}
  if [ -n "$glassfish" ]; then
    local domain_found=`$glassfish list-domains --domaindir "${domain_dir}" | grep "${domain_name}"`
    if [ -n "$domain_found" ]; then
      $glassfish delete-domain --domaindir "${domain_dir}" "${domain_name}"
      # TODO !!! after a domain is running there is a server.log file in the domain directory,
      # and the delete-domain command deletes everything except the log files... and if there is any
      # file still in the domain directory then a subsequent create-domain command will fail. so 
      # we need to delete the domain_dir/domain_name folder completely. but since this script will
      # probably be run as root, we want to be sure that we don't accidentally rm -rf /  or /opt etc.
      # SO, we need to check that domain_name is not blank and that domain_dir is not blank or just "/"...
      # but don't even try to do that manually because we'll miss something, like "/.././" 
      #rm -rf "${domain_dir}/${domain_name}"
    fi
  fi
}

glassfish_create_ssl_cert_prompt() {
    #echo_warning "This feature has been disabled: glassfish_create_ssl_cert_prompt"
    #return
    # SSL Certificate setup
    #local should_create_sslcert
    prompt_yes_no GLASSFISH_CREATE_SSL_CERT "Do you want to set up an SSL certificate for Glassfish?"
    echo
    if [ "${GLASSFISH_CREATE_SSL_CERT}" == "yes" ]; then
      if no_java ${JAVA_REQUIRED_VERSION:-1.6}; then echo "Cannot find Java ${JAVA_REQUIRED_VERSION:-1.6} or later"; return 1; fi
      glassfish_require
      prompt_with_default GLASSFISH_SSL_CERT_CN "Domain name for SSL Certificate:" ${MTWILSON_SERVER:-127.0.0.1}
      glassfish_create_ssl_cert "${GLASSFISH_SSL_CERT_CN}"
    fi
}

# TODO this functionality is moving to the java tool ; completely remove it from here
# Parameters:
# - serverName (hostname in the URL, such as 127.0.0.1, 192.168.1.100, my.attestation.com, etc.)
# XXX this function assumes we're using the first glassfish domain... usually "domain1"
glassfish_create_ssl_cert() {
#  echo_warning "This feature has been disabled: glassfish_create_ssl_cert"
#  return
  if no_java ${JAVA_REQUIRED_VERSION:-1.6}; then echo "Cannot find Java ${JAVA_REQUIRED_VERSION:-1.6} or later"; return 1; fi
  glassfish_require
  local serverName="${1}"
  local keystorePassword=changeit
  local domain_found=`$glassfish list-domains | head -n 1 | awk '{ print $1 }'`
  local keystore=${GLASSFISH_HOME}/domains/${domain_found}/config/keystore.jks
  local keytool=${JAVA_HOME}/bin/keytool
  local mtwilson=`which mtwilson 2>/dev/null`
  # does the keystore already have a cert with this alias? the alias has to be s1as (too much work to change it) so we check to see if a separate certificate file has been saved, indicating that s1as has already been replaced.
  #local ssl_found=`$keytool -list -keystore $keystore -storepass $keystorePassword | grep PrivateKeyEntry | awk -F ',' '{ print $1 }' | grep ${serverName}`
  #if [ -n "$ssl_found" ]; then
  #if [ -f "${GLASSFISH_HOME}/domains/${domain_found}/config/ssl.${serverName}.crt" ]; then
  #  echo "SSL Certificate for ${serverName} already exists"
  # Check if there is already a certificate for this serverName in the Glassfish keystore
  local has_cert=`$keytool -list -v -alias s1as -keystore $keystore -storepass $keystorePassword | grep "^Owner:" | grep "CN=${serverName}"`
  if [ -n "$has_cert" ]; then
    echo "SSL Certificate for ${serverName} already exists"
  else
    echo "Creating SSL Certificate for ${serverName}..."
    $keytool -delete -alias s1as  -keystore $keystore -storepass $keystorePassword
    # NIARL code in Trust Agent uses Bouncy Castle APIs which require a Subject Alternative Name in the Server's SSL certificate in order to validate a certificate with an IP address in the subject.
    # Java 7 supports -ext san=ip:1.2.3.4    to add the extension.  Java 6 does not.  So we use the mtwilson command to generate it. 
    #$keytool -genkey -alias s1as -keysize 2048 -keyalg RSA -dname "CN=${serverName}, OU=Mt Wilson, C=US" -keystore $keystore -storepass $keystorePassword -keypass $keystorePassword -validity 3650
    #$mtwilson api CreateSSLCertificate "CN=${serverName}, OU=Mt Wilson, C=US" "ip:${serverName}" $keystore s1as "$keystorePassword"
    $mtwilson api CreateSSLCertificate "${serverName}" "ip:${serverName}" $keystore s1as "$keystorePassword"
    $keytool -export -alias s1as -file "${GLASSFISH_HOME}/domains/${domain_found}/config/ssl.${serverName}.crt" -keystore $keystore -storepass $keystorePassword 
    echo "Restarting Glassfish domain..."
    glassfish_restart
  fi
}

### FUNCTION LIBRARY: tomcat

# tomcat 

tomcat_clear() {
  TOMCAT_HOME=""
  tomcat_bin=""
  tomcat=""
}


tomcat_require() {
  local min_version="${1:-${TOMCAT_REQUIRED_VERSION:-$DEFAULT_TOMCAT_REQUIRED_VERSION}}"
  if not tomcat_ready; then
    tomcat_detect ${min_version} > /dev/null
  fi
  if not tomcat_ready; then
    echo_failure "Cannot find Tomcat server version $min_version or later"
    exit 1
  fi
}

tomcat_ready_report() {
  if [[ -z "$TOMCAT_HOME" ]]; then echo_warning "TOMCAT_HOME variable is not set"; return 1; fi
  if [[ -z "$tomcat_bin" ]]; then echo_warning "Tomcat binary path is not set"; return 1; fi
  if [[ ! -f "$tomcat_bin" ]]; then echo_warning "Cannot find Tomcat binary at $tomcat_bin"; return 1; fi
  if [[ -z "$tomcat" ]]; then echo_warning "Tomcat command is not set"; return 1; fi
  echo_success "Using Tomcat at $TOMCAT_HOME"
  return 0
}


tomcat_ready() {
  tomcat_ready_report > /dev/null
  return $?
}

# How to use;   GLASSFISH_VERSION=`glassfish_version`
# If you pass a parameter, it is the path to a glassfish "asadmin" binary
# If you do not pass a parameter, the "glassfish" variable is used as the path to the binary
tomcat_version() {
  # Either the JAVA_HOME or the JRE_HOME environment variable must be defined
  # At least one of these environment variable is needed to run this program
  if [[ -z $JAVA_HOME && -z $JRE_HOME ]]; then return 1; fi

  if [[ -n "$tomcat" ]]; then
    # extract the version number from a string like: glassfish version "3.0"
    local current_tomcat_version=`$tomcat version 2>&1 | grep -i "^Server version:" | grep -i version | awk -F / '{ print $2 }'`
    if [ -n "$current_tomcat_version" ]; then
      echo $current_tomcat_version
      export TOMCAT_VERSION=$current_tomcat_version
      return 0
    fi
    return 2
  fi
  return 1
}

# sample output from "$tomcat version":
#Using CATALINA_BASE:   /usr/share/apache-tomcat-6.0.29
#Using CATALINA_HOME:   /usr/share/apache-tomcat-6.0.29
#Using CATALINA_TMPDIR: /usr/share/apache-tomcat-6.0.29/temp
#Using JRE_HOME:        /usr/share/jdk1.6.0_29
#Using CLASSPATH:       /usr/share/apache-tomcat-6.0.29/bin/bootstrap.jar
#Server version: Apache Tomcat/6.0.29
#Server built:   July 19 2010 1458
#Server number:  6.0.0.29
#OS Name:        Linux
#OS Version:     3.0.0-12-server
#Architecture:   amd64
#JVM Version:    1.6.0_29-b11
#JVM Vendor:     Sun Microsystems Inc.


# Environment:
# - TOMCAT_REQUIRED_VERSION  (default is 6.0.29)
tomcat_version_report() {
  local min_version="${1:-${TOMCAT_REQUIRED_VERSION:-$DEFAULT_TOMCAT_REQUIRED_VERSION}}"
  #TOMCAT_VERSION=`tomcat_version`
  tomcat_version
  if is_version_at_least "$TOMCAT_VERSION" "${min_version}"; then
    echo_success "Tomcat version $TOMCAT_VERSION is ok"
    return 0
  else
    echo_warning "Tomcat version $TOMCAT_VERSION is not supported, minimum is ${min_version}"
    return 1
  fi
}

# detects possible tomcat installations
# does nothing if TOMCAT_HOME is already set; unset before calling to force detection
tomcat_detect() {
  local min_version="${1:-${TOMCAT_REQUIRED_VERSION:-${DEFAULT_TOMCAT_REQUIRED_VERSION}}}"

      if [[ -n "$java" ]]; then    
        local java_bindir=`dirname $java`
      fi

  # start with TOMCAT_HOME if it is already configured
  if [[ -n "$TOMCAT_HOME" ]]; then
    if [[ -z "$tomcat_bin" ]]; then
      tomcat_bin="$TOMCAT_HOME/bin/catalina.sh"
    fi
    if [[ -z "$tomcat" ]]; then
      if [[ -n "$java" ]]; then    
        # the glassfish admin tool read timeout is in milliseconds, so 900,000 is 900 seconds
        tomcat="env PATH=$java_bindir:$PATH $tomcat_bin"
      else
        tomcat="$tomcat_bin"
      fi
    fi
    if [[ -n "$tomcat" ]]; then
      #TOMCAT_VERSION=`tomcat_version`
      tomcat_version
      if is_version_at_least "$TOMCAT_VERSION" "${min_version}"; then
        return 0
      fi
    fi
  fi

  TOMCAT_CANDIDATES=`find / -name tomcat-users.xml 2>/dev/null`
  tomcat_clear
  echo "debug TOMCAT_CANDIDATES: ${TOMCAT_CANDIDATES}"
  for c in $TOMCAT_CANDIDATES
  do
    #echo "debug tomcat candidate: $c"
    if [ -z "$TOMCAT_HOME" ]; then
      local bin_dir=`dirname $c`
      local parent=`dirname $bin_dir`
      if [ -f "$parent/bin/catalina.sh" ]; then
        export TOMCAT_HOME="$parent"
        export TOMCAT_BASE="$parent"
        conf_dir=`find / -name tomcat-users.xml 2>/dev/null`
        export TOMCAT_CONF=`dirname $conf_dir`
        tomcat_bin=$parent/bin/catalina.sh
        tomcat="env PATH=$java_bindir:$PATH JAVA_HOME=$JAVA_HOME CATALINA_HOME=$TOMCAT_HOME CATALINA_BASE=$TOMCAT_BASE CATALINA_CONF=$TOMCAT_CONF $tomcat_bin"
        echo "Found Tomcat: $TOMCAT_HOME"
        echo "tomcat=$tomcat"
        tomcat_version
        if is_version_at_least "$TOMCAT_VERSION" "${min_version}"; then
          return 0
        fi
        tomcat_clear
      fi
    fi
  done
}

tomcat_install() {
  tomcat_detect
  if [[ -z "$TOMCAT_HOME" || -z "$tomcat" ]]; then
    if [[ -n "$TOMCAT_PACKAGE" && -f "$TOMCAT_PACKAGE" ]]; then
      echo "Installing $TOMCAT_PACKAGE"
      #if [ -d "${tomcat_parent_dir}/${tomcat_name}" ]; then
      #    local datestr=`date +%Y-%m-%d.%H%M`
      #    echo "Renaming existing incomplete ${tomcat_parent_dir}/${tomcat_name} to ${tomcat_parent_dir}/${tomcat_name}.${datestr}"
      #    mv $tomcat_parent_dir/$tomcat_name $tomcat_parent_dir/${tomcat_name}.${datestr}
      #fi
      gunzip -c $TOMCAT_PACKAGE | tar xf - 2>&1  >/dev/null
      local tomcat_folder=`echo $TOMCAT_PACKAGE | awk -F .tgz '{ print $1 }'`
      mv $tomcat_folder /usr/share
     tomcat_detect
    else
      TOMCAT_YUM_PACKAGES="tomcat6"
      TOMCAT_APT_PACKAGES="tomcat6"
      auto_install "Tomcat via package manager" "TOMCAT"
      tomcat_detect
    fi
  fi
  
  if [[ -z "$TOMCAT_HOME" || -z "$tomcat" ]]; then
    echo "Unable to auto-install Tomcat"
    echo "  Tomcat download URL:"
    echo "  http://tomcat.apache.org/"
  fi

}

# Run this AFTER tomcat_install
# optional global variables:  
#   tomcat_username (default value tomcat)
#   TOMCAT_HOME (default value /usr/share/tomcat)
# works on Debian, Ubuntu, CentOS, RedHat, SUSE
# Username should not contain any spaces or punctuation
# Optional arguments:  one or more directories for tomcat user to own
tomcat_permissions() {
  local chown_locations="$@"
  local username=${TOMCAT_USERNAME:-tomcat}
  local user_exists=`cat /etc/passwd | grep "^${username}"`
  if [ -z "$user_exists" ]; then
    useradd -c "tomcat" -d "${TOMCAT_HOME:-/var}" -r -s /bin/bash "$username"
  fi
  local file
  for file in $chown_locations
  do
    if [[ -n "$file" && -e "$file" ]]; then
      chown -R "${username}:${username}" "$file"
    fi
  done
}

tomcat_running() {  
  TOMCAT_RUNNING=''
  if [ -n "$TOMCAT_HOME" ]; then
    TOMCAT_PID=`ps gauwxx | grep java | grep -v grep | grep "$TOMCAT_HOME" | awk '{ print $2 }'`
    echo TOMCAT_PID: $TOMCAT_PID
    if [ -n "$TOMCAT_PID" ]; then
      TOMCAT_RUNNING=yes
      echo TOMCAT_RUNNING: $TOMCAT_RUNNING
      return 0
    fi
  fi
  return 1
}

tomcat_running_report() {
  echo -n "Checking Tomcat process... "
  if tomcat_running; then
    echo "Running (pid $TOMCAT_PID)"
  else
    echo "Not running"
  fi
}
tomcat_start() {
  if [ -n "$tomcat" ]; then
      $tomcat start
  fi
}
tomcat_stop() {
  if [ -n "$tomcat" ]; then
      $tomcat stop
  fi
}
tomcat_restart() {
  if [ -n "$tomcat" ]; then
      $tomcat stop
      sleep 5
      $tomcat start
      sleep 5
  fi
}
tomcat_shutdown() {
  if tomcat_running; then
    if [ -n "$TOMCAT_PID" ]; then
        kill -9 $TOMCAT_PID
    fi
  fi
}
tomcat_start_report() {
  action_condition TOMCAT_RUNNING "Starting Tomcat" "tomcat_start > /dev/null; tomcat_running;"
}
# TODO this functionality is moving to the java tool ; completely remove it from here
# Parameters:
# - serverName (hostname in the URL, such as 127.0.0.1, 192.168.1.100, my.attestation.com, etc.)
tomcat_create_ssl_cert() {
#  echo_warning "This feature has been disabled: tomcat_create_ssl_cert"
#  return
  if no_java ${JAVA_REQUIRED_VERSION:-1.6}; then echo "Cannot find Java ${JAVA_REQUIRED_VERSION:-1.6} or later"; return 1; fi
  tomcat_require
  

  local serverName="${1}"
  local keystorePassword=changeit
  local keystore=${TOMCAT_HOME}/ssl/.keystore
  local keytool=${JAVA_HOME}/bin/keytool
  local mtwilson=`which mtwilson 2>/dev/null`
  local has_cert
  if [ ! -f $keystore ]; then
    mkdir -p ${TOMCAT_HOME}/ssl
    $keytool -genkey -alias s1as -keyalg RSA  -keysize 2048 -keystore ${keystore} -storepass ${keystorePassword} "CN=tomcat, OU=Mt Wilson, O=Intel, L=Folsom, ST=CA, C=US" -validity 3650  -keypass ${keystorePassword}  
  fi
  
  if [ -f $keystore ]; then
    # Check if there is already a certificate for this serverName in the Glassfish keystore
    has_cert=`$keytool -list -v -alias s1as -keystore $keystore -storepass $keystorePassword | grep "^Owner:" | grep "CN=${serverName}"`
  fi

  if [ -n "$has_cert" ]; then
    echo "SSL Certificate for ${serverName} already exists"
  else
    echo "Creating SSL Certificate for ${serverName}..."
    #$keytool -delete -alias s1as  -keystore $keystore -storepass $keystorePassword
    $mtwilson api CreateSSLCertificate "${serverName}" "ip:${serverName}" $keystore s1as "$keystorePassword"
    $keytool -export -alias s1as -file "${TOMCAT_HOME}/ssl/ssl.${serverName}.crt" -keystore $keystore -storepass $keystorePassword 
    $keytool -import -trustcacerts -alias s1as -file ssl.${serverName}.crt -keystore $keytool -storepass ${keystorePassword}
    openssl x509 -in "${TOMCAT_HOME}/ssl/ssl.${serverName}.crt" -inform der -out "${TOMCAT_HOME}/ssl/ssl.${serverName}.crt.pem" -outform pem
    
    sed -i.bak 's/sslProtocol=\"TLS\"/sslProtocol=\"TLS\" SSLCertificateFile=\"${catalina.base}\/ssl\/ssl.${serverName}.crt\" SSLCertificateKeyFile=\"${catalina.base}\/ssl\/ssl.${serverName}.crt.pem\"/g' ${TOMCAT_HOME}/conf/server.xml
    cp ${keystore} /root/

  fi
}


### FUNCTION LIBRARY: java

java_clear() {
  JAVA_HOME=""
  java=""
  JAVA_VERSION=""
}

# Returns success (0) if the JAVA_HOME and java variables are set and if the java binary exists.
# Returns error (1) otherwise and displays the issue as a warning.
# Quick and repeatable. No side effects.
# Example:   if not java_ready; then java_ready_report; fi
# Note: We do NOT check JAVA_VERSION here because if someone has configured a specific Java they want to use,
# we don't care what version it is as long as it is present.  In contrast, the java_detect function sets JAVA_VERSION
java_ready_report() {
  if [[ -z "$JAVA_HOME" ]]; then echo_warning "JAVA_HOME variable is not set"; return 1; fi
  if [[ -z "$java" ]]; then echo_warning "Java binary path is not set"; return 1; fi
  if [[ ! -f "$java" ]]; then echo_warning "Cannot find Java binary at $java"; return 1; fi
  echo_success "Using Java at $java"
  return 0
}

# Returns success (0) if the JAVA_HOME and java variables are set and if the java binary exists.
# Returns error (1) otherwise.
# Quick and repeatable. No side effects.
# Example:   if java_ready; then $java -jar start.jar; fi
java_ready() {
  java_ready_report > /dev/null
  return $?
}


# prints the current java version
# return codes:
# 0 - success
# 1 - java command not found
# 2 - cannot get version number using java command
# Environment:
# - java  (path to java binary) you can get it by calling java_detect 
#    (or if you are calling this from java_detect you set it yourself)
java_version() {
  if [ -n "$java" ]; then
    # extract the version number from a string like: java version "1.6.0_29"
    local current_java_version=`$java -version 2>&1 | head -n 1 | sed -e 's/"//g' | awk '{ print $3 }'`
    if [ -n "$current_java_version" ]; then
      echo $current_java_version
      return 0
    fi
    return 2
  fi
  return 1
}

# Environment:
# - JAVA_REQUIRED_VERSION
java_version_report() {
  local min_version="${1:-${JAVA_REQUIRED_VERSION:-${DEFAULT_JAVA_REQUIRED_VERSION}}}"
  local current_version=`java_version`
  if is_java_version_at_least "$current_version" "${min_version}"; then
    echo_success "Java version $current_version is ok"
    return 0
  else
    echo_warning "Java version $current_version is not supported, minimum is ${min_version}"
    return 1
  fi
}


# detects possible java installations
# does nothing if JAVA_HOME is already set; unset before calling to force detection
# uses the first installation found that meets the version requirement.
# prefers JDK over JRE installations, and prefers JRE over system-provided java
# This is not because JDK is better than JRE is better than system-provided java,
# but because if the system administrator has bothered to install the JDK or JRE
# it's clear he prefers to use that over the system-provided java.
# Environment:
# - JAVA_REQUIRED_VERSION should be set like 1.6 or 1.6.0_29 ; if not set then DEFAULT_JAVA_REQUIRED_VERSION is used
# Return code:  0 if java matching minimum version is found, 1 otherwise
# Postcondition:  on success, JAVA_HOME, java, and JAVA_VERSION are set;  on failure to find java they are cleared
java_detect() {
  local min_version="${1:-${JAVA_REQUIRED_VERSION:-${DEFAULT_JAVA_REQUIRED_VERSION}}}"
  # start with JAVA_HOME if it is already configured
  if [[ -n "$JAVA_HOME" ]]; then
    if [[ -z "$java" ]]; then
      java=${JAVA_HOME}/bin/java
    fi
    JAVA_VERSION=`java_version`
    if is_java_version_at_least "$JAVA_VERSION" "${min_version}"; then
      return 0
    fi
  fi

    JAVA_JDK_CANDIDATES=`find / -name java 2>/dev/null | grep jdk | grep -v jre | grep bin/java`
    for c in $JAVA_JDK_CANDIDATES
    do
        local java_bindir=`dirname $c`
        if [ -f "$java_bindir/java" ]; then
          export JAVA_HOME=`dirname $java_bindir`
          java=$c
          JAVA_VERSION=`java_version`
          echo "Found Java: $JAVA_HOME"
          if is_java_version_at_least "$JAVA_VERSION" "${min_version}"; then
            return 0
          fi
        fi
    done
    
    echo "Cannot find JDK"

    JAVA_JRE_CANDIDATES=`find / -name java 2>/dev/null | grep jre | grep bin/java`
    for c in $JAVA_JRE_CANDIDATES
    do
        java_bindir=`dirname $c`
        if [ -f "$java_bindir/java" ]; then
          export JAVA_HOME=`dirname $java_bindir`
          java=$c
          JAVA_VERSION=`java_version`
          echo "Found Java: $JAVA_HOME"
          if is_java_version_at_least "$JAVA_VERSION" "${min_version}"; then
            return 0
          fi
        fi
    done

    echo "Cannot find JRE"

    JAVA_BIN_CANDIDATES=`find / -name java 2>/dev/null | grep bin/java`
    for c in $JAVA_BIN_CANDIDATES
    do
        java_bindir=`dirname $c`
        # in non-JDK and non-JRE folders the "java" command may be a symlink:
        if [ -f "$java_bindir/java" ]; then
          export JAVA_HOME=`dirname $java_bindir`
          java=$c
          JAVA_VERSION=`java_version`
          echo "Found Java: $c"
          if is_java_version_at_least "$JAVA_VERSION" "${min_version}"; then
            return 0
          fi
        elif [ -h "$java_bindir/java" ]; then
          local javatarget=`readlink $c`
          if [ -f "$javatarget" ]; then
            java_bindir=`dirname $javatarget`
            export JAVA_HOME=`dirname $java_bindir`
            java=$javatarget
            JAVA_VERSION=`java_version`
            echo "Found Java: $java"
            if is_java_version_at_least "$JAVA_VERSION" "${min_version}"; then
              return 0
            fi
          else
            echo_warning "Broken link $c -> $javatarget"
          fi
        fi
    done

    echo "Cannot find system Java"

  echo_failure "Cannot find Java"
  java_clear
  return 1
}

# must load from config file or call java_detect prior to calling this function
java_env_report() {
  echo "JAVA_HOME=$JAVA_HOME"
  echo "java_bindir=$java_bindir"
  echo "java=$java"
}


# if java home and java bin are already configured and meet the minimum version, does nothing
# if they are not configured it initiates java detect to find them
# if
# Environment:
# - JAVA_REQUIRED_VERSION in the format "1.6.0_29" (or pass it as a parameter)
java_require() {
  local min_version="${1:-${JAVA_REQUIRED_VERSION:-${DEFAULT_JAVA_REQUIRED_VERSION}}}"
  if [[ -z "$JAVA_HOME" || -z "$java" || ! -f "$java" ]]; then
    java_detect ${min_version} > /dev/null
  fi
  JAVA_VERSION=`java_version`
  if is_java_version_at_least "$JAVA_VERSION" "${min_version}"; then
    return 0
  fi
  echo_failure "Cannot find Java version $min_version or later"
  return 1
}

# usage:  if no_java 1.6; then echo_failure "Cannot find Java"; exit 1; fi
no_java() {
  java_require $1
  if [ $? -eq 0 ]; then return 1; else return 0; fi
}

# Environment:
# - JAVA_REQUIRED_VERSION in the format "1.6.0_29"
java_install_openjdk() {
  JAVA_YUM_PACKAGES="java-1.6.0-openjdk java-1.6.0-openjdk-devel"
  JAVA_APT_PACKAGES="openjdk-6-jre openjdk-6-jdk"
  java_detect
  if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
    auto_install "Java" "JAVA"
    java_detect
    if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
      echo_failure "Cannot install Java"
      echo "Java download URL:"
      echo "http://www.java.com/en/download/"
    fi
  else
    echo "Java is already installed"
  fi
}

java_install() {
  local JAVA_PACKAGE="${1-:jdk-6u29-linux-x64.bin}"
#  JAVA_YUM_PACKAGES="java-1.6.0-openjdk java-1.6.0-openjdk-devel"
#  JAVA_APT_PACKAGES="openjdk-6-jre openjdk-6-jdk"
#  auto_install "Java" "JAVA"
  java_clear; java_detect >> $INSTALL_LOG_FILE
  if no_java ${JAVA_REQUIRED_VERSION:-1.6} >> $INSTALL_LOG_FILE; then
    if [[ -z "$JAVA_PACKAGE" || ! -f "$JAVA_PACKAGE" ]]; then
      echo_failure "Missing Java installer: $JAVA_PACKAGE" | tee -a 
      return 1
    fi
    local javafile=$JAVA_PACKAGE
    echo "Installing $javafile"  >> $INSTALL_LOG_FILE
    is_gzip=`echo $javafile | grep ".gz$"`
    is_bin=`echo $javafile | grep ".bin$"`
    javaname=`echo $javafile | awk -F . '{ print $1 }'`
    if [ -n "$is_gzip" ]; then
      gunzip $javafile 2>&1 >/dev/null  >> $INSTALL_LOG_FILE
      chmod +x $javaname
      ./$javaname | grep -vE "inflating:|creating:|extracting:|linking:|^Creating" 
    elif [ -n "$is_bin" ]; then
      chmod +x $javafile
      ./$javafile | grep -vE "inflating:|creating:|extracting:|linking:|^Creating"  
    fi
    # java gets unpacked in current directory but they cleverly
    # named the folder differently than the archive, so search for it:
    local java_unpacked=`ls -1d jdk* jre* 2>/dev/null`
    for f in $java_unpacked
    do
      #echo "$f"
      if [ -d "$f" ]; then
        mv "$f" /usr/share
      fi
    done
    java_detect  >> $INSTALL_LOG_FILE
    if [[ -z "$JAVA_HOME" || -z "$java" ]]; then
      echo_failure "Unable to auto-install Java" | tee -a $INSTALL_LOG_FILE
      echo "  Java download URL:"                >> $INSTALL_LOG_FILE
      echo "  http://www.java.com/en/download/"  >> $INSTALL_LOG_FILE
    fi
  else
    echo "Java is already installed"              >> $INSTALL_LOG_FILE
  fi
}

java_keystore_cert_report() {
  local keystore="${1:-keystore.jks}"
  local keystorePassword="${2:-changeit}"
  local alias="${3:-s1as}"
  local keytool=${JAVA_HOME}/bin/keytool
  local owner_expires=`$keytool -list -v -alias $alias -keystore $keystore -storepass $keystorePassword | grep -E "^Owner|^Valid"`
  echo "$owner_expires"
  local fingerprints=`$keytool -list -v -alias $alias -keystore $keystore -storepass $keystorePassword | grep -E "MD5:|SHA1:"`
  echo "$fingerprints"
}


### FUNCTION LIBARARY: prerequisites reporting


# environment dependencies report
print_env_summary_report() {
  echo "Requirements summary:"
  local error=0
  if [ -n "$JAVA_HOME" ]; then
    echo "Java: $JAVA_VERSION"
  else
    echo_failure "Java: not found"
    error=1
  fi
  if using_mysql; then
    if [ -n "$MYSQL_HOME" ]; then
      echo "Mysql: $MYSQL_CLIENT_VERSION"
    else
      echo_failure "Mysql: not found"
      error=1
    fi
  fi
  if using_postgres; then
    if [ -n "$POSTGRES_HOME" ]; then
      echo "Postgres: $POSTGRES_CLIENT_VERSION"
    else
      echo_failure "Postgres: not found"
      error=1
    fi
  fi
  if using_glassfish; then
    if [ -n "$GLASSFISH_HOME" ]; then
      GLASSFISH_VERSION=`glassfish_version`
      echo "Glassfish: $GLASSFISH_VERSION"
    else
      echo_failure "Glassfish: not found"
      error=1
    fi
  fi
  if using_tomcat; then
    if [ -n "$TOMCAT_HOME" ]; then
      echo "Tomcat: $TOMCAT_CLIENT_VERSION"
    else
      echo_failure "Tomcat: not found"
      error=1
    fi
  fi
  return $error
}


### FUNCTION LIBRARY: web service on top of web server

# parameters: webservice_application_name such as "AttestationService"
webservice_running() {
  local webservice_application_name="$1"
  echo "webservice_application_name: $webservice_application_name"
  WEBSERVICE_RUNNING=""
  if using_glassfish; then 
    glassfish_running
    if [ -n "$GLASSFISH_RUNNING" ]; then
      # TODO ??? check for the specific ATTESTATION_SERVICE_ID name defined in ${intel_conf_dir}/${package_env_filename}
      WEBSERVICE_DEPLOYED=`$glassfish list-applications | grep "${webservice_application_name}" | head -n 1 | awk '{ print $1 }'`
      if [ -n "$WEBSERVICE_DEPLOYED" ]; then
        WEBSERVICE_RUNNING=`$glassfish show-component-status $WEBSERVICE_DEPLOYED | grep enabled`
      fi
    fi
  elif using_tomcat; then
    tomcat_running
    echo "TOMCAT_RUNNING: $TOMCAT_RUNNING"
    if [ -n "$TOMCAT_RUNNING" ]; then
      # determine if this app is deployed
      echo "MTWILSON_SERVER: $MTWILSON_SERVER"
      WEBSERVICE_DEPLOYED=`wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/list -O - -q | grep "${webservice_application_name}" | head -n 1 | awk '{ print $1 }' | sed -e 's/:/\n/g' | grep "${webservice_application_name}"`
      echo "WEBSERVICE_DEPLOYED=$WEBSERVICE_DEPLOYED"
      #if deployed, make sure it is runnning
      if [ -n "$WEBSERVICE_DEPLOYED" ]; then
        WEBSERVICE_RUNNING=`wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/list -O - -q | grep "${webservice_application_name}" | head -n 1 | awk '{ print $1 }' | sed -e 's/:/\n/g' | grep "running"`
        echo "WEBSERVICE_RUNNING=$WEBSERVICE_RUNNING"
      fi
    fi
  fi
}
webservice_running_report() {
  local webservice_application_name="$1"
  echo -n "Checking ${webservice_application_name}... "
  webservice_running "${webservice_application_name}"
  if [ -n "$WEBSERVICE_RUNNING" ]; then
    echo "Running"
  else
    echo "Not running"
  fi
}


webservice_start() {
  local webservice_application_name="$1"
  webservice_running  "${webservice_application_name}"
  if [ -n "$WEBSERVICE_DEPLOYED" ]; then
    if using_glassfish; then
      $glassfish enable $WEBSERVICE_DEPLOYED
    elif using_tomcat; then
      wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/start?path=/${WEBSERVICE_DEPLOYED} -O - -q
    fi
  fi
}
webservice_stop() {
  local webservice_application_name="$1"
  webservice_running "${webservice_application_name}"
  if [ -n "$WEBSERVICE_DEPLOYED" ]; then
    if using_glassfish; then
      $glassfish disable $WEBSERVICE_DEPLOYED
    elif using_tomcat; then
      wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/stop?path=/${WEBSERVICE_DEPLOYED} -O - -q
    fi
  fi
}

webservice_start_report() {
    local webservice_application_name="$1"
    if using_glassfish; then
      glassfish_require
      glassfish_running
      if [ -z "$GLASSFISH_RUNNING" ]; then
          glassfish_start_report
      fi
    elif using_tomcat; then
      tomcat_require
      tomcat_running
      if [ -z "$TOMCAT_RUNNING" ]; then
          tomcat_start_report
      fi
    fi

    webservice_running "${webservice_application_name}"
    if [ -z "$WEBSERVICE_RUNNING" ]; then
          action_condition WEBSERVICE_RUNNING "Starting ${webservice_application_name}" "webservice_start ${webservice_application_name} > /dev/null; webservice_running ${webservice_application_name};"
    fi
    if [ -n "$WEBSERVICE_RUNNING" ]; then
          echo_success "${webservice_application_name} is running"
    fi
}
webservice_stop_report() {
    local webservice_application_name="$1"
    if using_glassfish; then
      glassfish_require
      glassfish_running
    elif using_tomcat; then
      tomcat_require
      tomcat_running
    fi
    webservice_running "${webservice_application_name}"
    if [ -n "$WEBSERVICE_RUNNING" ]; then
        inaction_condition WEBSERVICE_RUNNING "Stopping ${webservice_application_name}" "webservice_stop ${webservice_application_name} > /dev/null; webservice_running ${webservice_application_name};"
    fi
    
    if [ -z "$WEBSERVICE_RUNNING" ]; then
      echo_success "${webservice_application_name} is stopped"
    fi
}


# parameters:
# webservice_application_name such as "AttestationService"
# webservice_war_file such as "/path/to/AttestationService-0.5.1.war"
# Environment:
# - glassfish_required_version
webservice_install() {
  local webservice_application_name="$1"
  local webservice_war_file="$2"
#  if using_glassfish; then
#    glassfish_require
#  elif using_tomcat; then
#      tomcat_require
#  fi

  webservice_running "${webservice_application_name}"

  local WAR_FILE="${webservice_war_file}"
    if [ -n "$WEBSERVICE_DEPLOYED" ]; then
      if using_glassfish; then
        echo "Re-deploying ${WEBSERVICE_DEPLOYED} to Glassfish..."
        ${glassfish} redeploy --name ${WEBSERVICE_DEPLOYED} ${WAR_FILE}
      elif using_tomcat; then
        echo "Re-deploying ${WEBSERVICE_DEPLOYED} to Glassfish..."
        wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/reload?path=/${WEBSERVICE_DEPLOYED} -O -q
      fi
    else
      if using_glassfish; then
        echo "Deploying ${webservice_application_name} to Glassfish..."
        ${glassfish} deploy --name ${webservice_application_name} ${WAR_FILE}
      elif using_tomcat; then
        echo "Deploying ${webservice_application_name} to Tomcat..."
        cp ${webservice_war_file} $TOMCAT_HOME/webapps/
        #wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/deploy?path=/${webservice_application_name}&war=file:${webservice_war_file} -O -q
      fi
    fi
}

webservice_uninstall() {
  local webservice_application_name="$1"
  webservice_running "${webservice_application_name}"
  local WAR_NAME="${webservice_application_name}"
  if [ -n "$WEBSERVICE_DEPLOYED" ]; then
    if using_glassfish; then
      echo "Undeploying ${WEBSERVICE_DEPLOYED} from Glassfish..."
      ${glassfish} undeploy ${WEBSERVICE_DEPLOYED}
    elif using_tomcat; then
      echo "Undeploying ${WEBSERVICE_DEPLOYED} from Tomcat..."
      wget http://tomcat:tomcat@$MTWILSON_SERVER:8080/manager/undeploy?path=/${WEBSERVICE_DEPLOYED} -O -q
    fi
  else
    if using_glassfish; then
      echo "Application is not deployed on Glassfish; skipping undeploy"
    elif using_tomcat; then
      echo "Application is not deployed on Tomcat; skipping undeploy"
    fi
  fi
}

### FUNCTION LIBRARY: DATABASE FUNCTIONS

database_restart(){
  if using_glassfish; then
    glassfish_restart
  elif using_tomcat; then
    tomcat_restart
  fi
}

database_shutdown(){
  if using_glassfish; then
    glassfish_shutdown
  elif using_tomcat; then
    tomcat_shutdown
  fi
}
# determine database
which_dbms(){
  echo "Please identify the database which will be used for the Mt Wilson server.
The supported databases are m=MySQL | p=Postrges"
  while true; do
    prompt_with_default DATABASE_CHOICE "Choose Database:" "p";

    if [ "$DATABASE_CHOICE" != 'm' ] && [ "$DATABASE_CHOICE" != 'p' ]; then
      echo "Be serious.  Common, try again: "
      DATABASE_CHOICE=
    else
      if [ "$DATABASE_CHOICE" = 'm' ]; then 
        export DATABASE_VENDOR="mysql"
      else
        export DATABASE_VENDOR="postgres"
      fi
      break
    fi
  done
  echo "Database Choice: $DATABASE_VENDOR"
}

# determine web server
which_web_server(){
echo "Please identify the web server which will be used for the Mt Wilson server.
The supported servers are g=Glassfish | t=Tomcat"
  while true; do
    prompt_with_default WEBSERVER_CHOICE "Choose Web Server:" "t";

    if [ "$WEBSERVER_CHOICE" != 't' ] && [ "$WEBSERVER_CHOICE" != 'g' ]; then
      echo "Be serious.  Common, try again: "
      WEBSERVER_CHOICE=
    else
      if [ "$WEBSERVER_CHOICE" = 't' ]; then 
        export WEBSERVER_VENDOR="tomcat"
      else
        export WEBSERVER_VENDOR="glassfish"
      fi
      break
    fi
  done
  echo "Web Server Choice: $WEBSERVER_VENDOR"
}
# parameters:
# 1. path to properties file
# 2. properties prefix (for mountwilson.as.db.user etc. the prefix is mountwilson.as.db)
# the default prefix is "postgres" for properties like "postgres.user", etc. The
# prefix must not have any spaces or special shell characters
postgres_read_connection_properties() {
    local config_file="$1"
    local prefix="${2:-postgres}"
    POSTGRES_HOSTNAME=`read_property_from_file ${prefix}.host "${config_file}"`
    POSTGRES_PORTNUM=`read_property_from_file ${prefix}.port "${config_file}"`
    POSTGRES_USERNAME=`read_property_from_file ${prefix}.user "${config_file}"`
    POSTGRES_PASSWORD=`read_property_from_file ${prefix}.password "${config_file}"`
    POSTGRES_DATABASE=`read_property_from_file ${prefix}.schema "${config_file}"`
}
postgres_write_connection_properties() {
    local config_file="$1"
    local prefix="${2:-postgres}"
    update_property_in_file ${prefix}.host "${config_file}" "${POSTGRES_HOSTNAME}"
    update_property_in_file ${prefix}.port "${config_file}" "${POSTGRES_PORTNUM}"
    update_property_in_file ${prefix}.user "${config_file}" "${POSTGRES_USERNAME}"
    update_property_in_file ${prefix}.password "${config_file}" "${POSTGRES_PASSWORD}"
    update_property_in_file ${prefix}.schema "${config_file}" "${POSTGRES_DATABASE}"
    update_property_in_file ${prefix}.driver "${config_file}" "org.postgresql.Driver"

}

# parameters:
# - configuration filename (absolute path)
# - property prefix for settings in the configuration file (java format is assumed, dot will be automatically appended to prefix)
postgres_userinput_connection_properties() {
    echo "Configuring DB Connection..."
    prompt_with_default POSTGRES_HOSTNAME "Hostname:" ${DEFAULT_POSTGRES_HOSTNAME}
    prompt_with_default POSTGRES_PORTNUM "Port Num:" ${DEFAULT_POSTGRES_PORTNUM}
    prompt_with_default POSTGRES_DATABASE "Database:" ${DEFAULT_POSTGRES_DATABASE}
    prompt_with_default POSTGRES_USERNAME "Username:" ${DEFAULT_POSTGRES_USERNAME}
    prompt_with_default_password POSTGRES_PASSWORD "Password:" ${DEFAULT_POSTGRES_PASSWORD}
}

# Set config file db properties
set_config_db_properties() {
  local scriptname="$1"
  local packagename="$2"
  intel_conf_dir=/etc/intel/cloudsecurity
  package_dir=/opt/intel/cloudsecurity/${packagename}
  package_config_filename=${intel_conf_dir}/${packagename}.properties
  package_env_filename=${package_dir}/${packagename}.env
  package_install_filename=${package_dir}/${packagename}.install
}
