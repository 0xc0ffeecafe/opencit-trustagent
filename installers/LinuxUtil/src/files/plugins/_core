#!/bin/sh

# This file defines some functions that can be considered
# extension points, or abstract, or basic implementations
# of common features.
# The filename starts with an underscore so that it will
# be loaded before other plugins and give other plugins
# a chance to override these methods.

# Functions in optional modules may override these with
# improved or customized implementations.
# For example, the echo_warning and echo_failure functions
# defined here simply do a regular echo, but there is a
# colorful version defined by the color plugin.

TERM_DISPLAY_MODE=plain

echo_success() {
  echo "$@"
  return 0
}

echo_warning() {
  echo "$@"
  return 1
}

echo_failure() {
  echo "$@"
  return 1
}


# Parameters:
# - character like 'a' for which to echo the character code
# echos the character code of the specified character
# For example:   ord a     will echo 97
ord() { printf '%d' "'$1"; }





### FUNCTION LIBRARY: environment information functions

# Usage example:   if using_glassfish; then echo "Using glassfish"; fi
using_glassfish() { if [[ "${WEBSERVER_VENDOR}" == "glassfish" ]]; then return 0; else return 1; fi }
using_tomcat() { if [[ "${WEBSERVER_VENDOR}" == "tomcat" ]]; then return 0; else return 1; fi }
using_mysql() { if [[ "${DATABASE_VENDOR}" == "mysql" ]]; then return 0; else return 1; fi }
using_postgres() { if [[ "${DATABASE_VENDOR}" == "postgres" ]]; then return 0; else return 1; fi }

### FUNCTION LIBARRY: conditional execution functions

# TODO: rename to positive_condition
# parameters: condition variable name, status line, code to run
# Will print "status line... " and then "OK" or "FAILED"
action_condition() {
  local condvar="${1}"
  local statusline="${2}"
  local condfn="${3}"
  local cond=$(eval "echo \$${condvar}")
  echo -n "$statusline"
  echo -n "... "
  if [ -n "$cond" ]; then
    echo_success "Skipped"
  else # if [ -z "$cond" ]; then
    eval "$condfn"
    cond=$(eval "echo \$${condvar}")
    if [ -n "$cond" ]; then
      echo_success "OK"
    else
      echo_failure "FAILED"
    fi
  fi
}
# TODO: rename to negative_condition
# similar to action_condition but reverses the logic: empty is OK, defined is FAILED
inaction_condition() {
  local condvar="${1}"
  local statusline="${2}"
  local condfn="${3}"
  local cond=$(eval "echo \$${condvar}")
  echo -n "$statusline"
  echo -n "... "
  if [ -z "$cond" ]; then
    echo_success "Skipped"
  else # if [ -z "$cond" ]; then
    eval "$condfn"
    cond=$(eval "echo \$${condvar}")
    if [ -z "$cond" ]; then
      echo_success "OK"
    else
      echo_failure "FAILED"
    fi
  fi
}
