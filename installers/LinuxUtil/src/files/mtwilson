#!/bin/bash
# WARNING:
# *** do NOT use TABS for indentation, use SPACES
# *** TABS will cause errors in some linux distributions

logfile=/var/log/mtwilson.log
plugindir=/usr/share/mtwilson/script/plugins
cmdprefix=mw

# Set to "true" to show "Loading <plugin>..." lines
# Set to "false" to hide them
debug_plugin=false

# input:  filename (relative or absolute)
# output: success (0) if file begins with #!/bin/sh
#         error (1) if file is not found
#         error (2) if file does not begin with #!/bin/sh
is_shell_script() {
  local file="$1"
  if [ -f "$file" ]; then
    local firstline=`head -n 1 $file`
    # we could also do firstline=`head -n 1 $file | tr -d '\040\011\012\015'` to strip out newlines
    # but the fact is if a CR at the end of the line is causing an issue  the shell won't load that
    # plugin anyway so we are correctly failing it as a possible shell script to avoid errors.
    if [ "#\!/bin/sh" == "$firstline" ] || [ "#\!/bin/bash" == "$firstline" ]; then
      return 0
    fi
    return 2
  fi
  return 1
}

# populates a variable AVAILABLE_PLUGINS with the list
# of plugin names (no paths, they are assumed to be in plugin dir)
set_available_plugins() {
  AVAILABLE_PLUGINS=`ls -1 $plugindir`
}

# Checks if the given plugin name is installed in the plugins
# directory.
# Input:  plugin name, for example "tomcat"
# Output: returns success(0) if it's there and is a valid script, error (1) otherwise
isplugin() {
  local pluginfile="$1"
  local pluginfilepath="$plugindir/$pluginfile"
  if is_shell_script "$pluginfilepath"; then
    return 0
  fi
  return 1
}


# Given a plugin name (not full path) attempts to load it
# from the plugin dir and returns 0 on success, 1 on error
# Plugin file requirements:
# - First line is #!/bin/sh
# - In general plugins should only define functions, and not
#   run anything outside of functions
# - Any code outside of functions will be executed immediately
#   when the plugin is loaded, so it must be crafted carefully
#   so it does not interefere with the main program or other
#   plugins
# - All functions defined in a plugin will be available to all
#   other plugins (including plugins loaded after this one)
#   and that works because any function calls within functions
#   are not checked by the shell until they are actually invoked
# - Functions that correspond to commands have a naming convention:
#   for example in "mtwilson tomcat start" the word "tomcat" is a
#   command, and the corresponding function must be named
#   "tomcat".  Hyphens in command names are allowed and are
#   automatically converted to underscores. For example the command
#   "tomcat-restart" is converted to "tomcat_restart"
loadplugin() {
  local pluginfile="$1"
  local pluginfilepath="$plugindir/$pluginfile"
  if is_shell_script "$pluginfilepath"; then
    $debug_plugin && echo "Loading $pluginfile..."
    . $pluginfilepath
    return 0
  else
    echo "Cannot load $pluginfilepath"
    return 1
  fi
}


# Input: command name (from command line)
# Output: corresponding function name (in plugin)
# Given a command name like "tomcat-restart" converts it
# to a function name like "tomcat_restart"
# The rule is that all hyphens are converted to underscores,
# and then anything that isn't a letter digit or underscore is
# deleted.
command_function_name() {
  local name="$1"
  #local converted=`echo "$name" | tr '-' '_'`
  #echo $converted
  echo "$name" | tr '-' '_' | tr -dc 'a-zA-Z0-9_'
}

# Input: function name
# Output:  success (0) if the function exists, error (1) if it doesn't
# Example: is_function do_something && do_something
is_function() {
  local result=`type $1 2>/dev/null | head -n 1`
  #if [ -n "$result" ]; then
  if [ "$result" == "$1 is a function" ]; then
    return 0
  fi
  return 1
}

# Looks for a function that is named like prefix_name
# where prefix is the value of cmdprefix variable declared
# at the top of this script, and name is the command
# name (probably typed in by the user like "mtwilson <command-name> args..."
find_command() {
  local inputname="$1"
  local underscored="${inputname//-/_}"
  local sanitized="${inputname//[^a-z0-9_]/}"
  local fn="${cmdprefix}_${sanitized}"
  if is_function $fn; then
    echo $fn
    return 0
  else
    return 1
  fi
}

# init
if [ ! -f $logfile ]; then touch $logfile; fi
if [ ! -d $plugindir ]; then mkdir -p $plugindir; fi
set_available_plugins
for pluginfile in $AVAILABLE_PLUGINS
do
  loadplugin $pluginfile
done

# from env plugin:
if isplugin env; then loadenv; fi

if isplugin log; then mw_log "$@"; fi

#parse_args $@

# Look for a command with this name defined by one of the
# plugins. If more than one plugin defines the samea command,
# the plugin with the "greater" (alphabetically) name will
# be loaded last and override any earlier definitions.
# Example input:  "version"
# Example output:  "mw_version"
cmd=`find_command $1`

# Shift once to remove the command's name from the list of
# arguments. So we only pass to the command arguments that
# were after its name.
shift

# Invoke the command with its arguments, and exit using whatever
# error code was returned from the command.
$cmd $@
exit $?

